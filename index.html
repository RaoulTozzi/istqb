<!doctype html>
<html lang="pl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ISTQB Syllabus Trainer</title>
<style>
  :root{
    --bg:#f1d6be; --panel:#ffeede; --card:#f6e6d6; --ink:#2b3a3a; --muted:#6b7a7a; --accent:#3b6a64; --accent-2:#2e4e4a; --ok:#2f855a; --warn:#b7791f; --err:#c53030;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.5 Inter,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif}
  header{position:sticky;top:0;z-index:10;background:var(--panel);box-shadow:0 1px 0 rgba(0,0,0,.05)}
  .bar{max-width:1200px;margin:auto;padding:12px 16px;display:flex;gap:12px;align-items:center}
  .brand{font-weight:800;letter-spacing:.3px}
  .spacer{flex:1}
  .btn{cursor:pointer;border:0;border-radius:12px;background:var(--accent);color:#fff;padding:10px 14px;font-weight:600}
  .btn.secondary{background:var(--accent-2)}
  .btn.flat{background:transparent;border:2px solid var(--accent);color:var(--accent)}
  .hint{color:var(--muted);font-size:12px}
  .layout{max-width:1200px;margin:14px auto;display:grid;grid-template-columns:280px 1fr;gap:16px;padding:0 16px}
  aside{background:var(--panel);border-radius:16px;padding:12px 10px;height:calc(100vh - 120px);position:sticky;top:86px;overflow:auto}
  .toc h3{margin:6px 10px 8px;font-size:14px;text-transform:uppercase;color:var(--muted)}
  .toc button{display:block;width:100%;text-align:left;background:transparent;border:0;border-radius:12px;padding:10px 12px;margin:4px 0;font-weight:600;color:var(--accent-2)}
  .toc button.active{background:var(--card);color:var(--ink)}
  main{min-height:60vh}
  .card{background:var(--panel);border-radius:20px;box-shadow:0 10px 30px rgba(0,0,0,.05);padding:18px}
  .reading{padding:4px 8px}
  .reading h2{margin:10px 0 6px}
  .reading p{margin:8px 0}
  .reading ul{margin:8px 0 8px 20px}
  .chapterHeader{position:sticky;top:6px;z-index:2;background:linear-gradient(var(--panel), var(--panel));padding:10px 12px;border-radius:12px;border:1px solid rgba(0,0,0,.06);display:flex;flex-direction:column;gap:6px}
  .chapterHeader.is-chapter{border-left:6px solid var(--accent)}
  .chapterHeader.is-sub{border-left:6px solid var(--accent-2)}
  .chapterHeader .row1{display:flex;align-items:center;gap:8px}
  .chapterHeader .crumb{font-weight:800}
  .chapterHeader .row2{display:flex;align-items:baseline;gap:10px}
  .chapterHeader .badge{display:inline-block;padding:2px 10px;border-radius:999px;background:var(--card);color:var(--muted);font-size:12px;font-weight:700;text-transform:uppercase;letter-spacing:.3px}
  .chapterHeader .chapterTitle{margin:0;font-size:20px}
  .pageFooter{display:flex;justify-content:space-between;margin-top:16px}
  .inline{margin-top:16px;padding:14px;border-radius:16px;background:#fff;border:1px solid rgba(0,0,0,.06)}
  .inline .flip{width:100%;min-height:120px;background:var(--card);border-radius:14px;display:flex;align-items:center;justify-content:center;padding:16px;text-align:center;cursor:pointer}
  .inline-quiz .opt{display:block;margin:6px 0;padding:8px;border-radius:10px;border:1px solid rgba(0,0,0,.08)}
  .controls{display:flex;gap:10px;flex-wrap:wrap;margin:10px 0}
  .flash{display:grid;place-items:center;gap:12px;padding:10px}
  .flash .flip{width:min(700px,100%);min-height:170px;background:var(--card);border-radius:18px;display:flex;align-items:center;justify-content:center;padding:24px;text-align:center;cursor:pointer;box-shadow:0 8px 18px rgba(0,0,0,.08)}
  .flip.flipped{background:#fff}
  .flash .row{display:flex;gap:8px}
  .tag{display:inline-block;border-radius:999px;padding:2px 10px;font-size:12px;background:var(--card);color:var(--muted);margin-right:6px}
  .quiz .q{margin:10px 0;padding:14px;border-radius:14px;background:var(--panel);border:1px solid rgba(0,0,0,.06)}
  .opt{display:block;margin:6px 0;padding:10px;border-radius:10px;cursor:pointer;border:1px solid rgba(0,0,0,.08)}
  .opt input{margin-right:6px}
  .opt.correct{background:rgba(47,133,90,.10);border-color:var(--ok)}
  .opt.wrong{background:rgba(197,48,48,.10);border-color:var(--err)}
  .explain{font-size:13px;color:var(--muted)}
  .result{padding:10px;border-radius:12px;background:#fff;margin:12px 0;border-left:6px solid var(--accent)}
  .muted{color:var(--muted)}
  footer{padding:30px 16px;text-align:center;color:var(--muted)}
  @media (max-width: 880px){
    .layout{grid-template-columns:1fr}
    aside{position:static;height:auto}
  }
</style>
</head>
<body>
  <header>
    <div class="bar">
      <div class="brand">ISTQB Syllabus Trainer</div>
      <div class="hint">Nauka rozdziałami → fiszki → mini‑testy → egzamin końcowy</div>
      <div class="spacer"></div>
      <a class="btn flat" href="egzamin_quiz_full.html" title="Pełny egzamin" style="text-decoration:none;display:inline-block;text-align:center">Egzamin</a>
      <button class="btn flat" id="resetBtn" title="Wyczyść postęp">Reset</button>
    </div>
  </header>

  <div class="layout">
    <aside>
      <div class="toc" id="toc"></div>
      <div class="card" style="margin-top:12px">
        <div style="font-weight:700;margin-bottom:6px">Postęp</div>
        <div class="hint" id="progressHint">—</div>
      </div>
    </aside>

    <main>
      <div class="card reading" id="reading"></div>
    </main>
  </div>

<script>
/** -------------------------------------------------------
 *  DANE – skróty treści, fiszki i pytania (PL)
 *  Wszystko w jednym pliku dla prostoty GitHub Pages.
 *  Możesz swobodnie rozszerzać.
 * ------------------------------------------------------*/
// Usunięto podgląd PDF — treści rozdziałów są renderowane wprost z danych
const syllabus = [
  {
    id:"r1",
    title:"1. Podstawy testowania",
    pages:[
      {
        id:"1.1",
        title:"1.1 Co to jest testowanie?",
        html:`<p>Systemy oprogramowania są nieodłączną częścią naszego codziennego życia. Jednocześnie większość z nas miała zapewne do czynienia z oprogramowaniem, które nie zadziałało tak, jak powinno. Nieprawidłowe funkcjonowanie oprogramowania może powodować wiele problemów, w tym straty finansowe, stratę czasu, utratę reputacji firmy, a w skrajnych przypadkach nawet utratę zdrowia lub życia. Odpowiedzią na ten problem jest właśnie testowanie oprogramowania, które pozwala ocenić jego jakość i zmniejszyć ryzyko wystąpienia awarii podczas eksploatacji.</p>
        <p>Testowanie oprogramowania to zbiór czynności mających na celu wykrycie defektów i dokonanie oceny jakości produktów pracy związanych z oprogramowaniem. W trakcie testowania produkty pracy te są nazywane przedmiotami testów. Powszechnie panuje błędne przekonanie, że testowanie polega wyłącznie na wykonywaniu testów, czyli uruchamianiu oprogramowania i sprawdzaniu uzyskanych rezultatów. W rzeczywistości jednak testowanie oprogramowania obejmuje również inne czynności i musi być dopasowane do cyklu wytwarzania oprogramowania.</p>
        <p>Inne nieporozumienie polega na postrzeganiu testowania jako czynności skupionej wyłącznie na weryfikowaniu przedmiotu testów. Chociaż w ramach testowania rzeczywiście sprawdza się, czy system spełnia wyspecyfikowane wymagania, to jednak przeprowadza się również walidację, której zadaniem jest sprawdzenie, czy system odpowiada na potrzeby użytkowników i innych interesariuszy w swoim środowisku produkcyjnym. 
        <p>Weryfikacja sprawdza zgodność ze specyfikacją, a walidacja — czy system odpowiada na potrzeby użytkowników i innych interesariuszy. Testowanie może mieć charakter dynamiczny (uruchamianie oprogramowania) lub statyczny (przeglądy i analiza statyczna). Testowanie wymaga również planowania, zarządzania, szacowania, monitorowania i nadzoru. Testerzy korzystają z narzędzi, ale testowanie to w dużej mierze praca umysłowa.</p>
        <h3>1.1.1 Cele testów</h3>
        <ul>
          <li>Dokonywanie oceny produktów pracy (wymagania, historyjki, projekty, kod).</li>
          <li>Powodowanie awarii i znajdowanie defektów.</li>
          <li>Zapewnienie wymaganego pokrycia przedmiotu testów.</li>
          <li>Obniżanie poziomu ryzyka związanego z niedostateczną jakością oprogramowania.</li>
          <li>Sprawdzanie spełnienia wymagań oraz zgodności umownej, prawnej i regulacyjnej.</li>
          <li>Dostarczanie interesariuszom informacji do podejmowania decyzji i budowanie zaufania.</li>
          <li>Sprawdzanie kompletności i zgodności z oczekiwaniami interesariuszy.</li>
        </ul>`,
        flashcards:[
          {q:"Wymień 3–4 typowe cele testów.", a:"Ocena produktów pracy; wykrywanie defektów/awarii; zapewnienie pokrycia; redukcja ryzyka; potwierdzenie wymagań i zgodności; dostarczenie informacji do decyzji; budowanie zaufania."},
          {q:"Czym różni się weryfikacja od walidacji?", a:"Weryfikacja sprawdza zgodność ze specyfikacją; walidacja sprawdza, czy system odpowiada na potrzeby użytkowników i interesariuszy."},
          {q:"Jakie są rodzaje testowania?", a:"Dynamiczne (uruchamianie oprogramowania) i statyczne (przeglądy i analiza statyczna)."}
        ],
      },
      {
        id:"1.1.2",
        title:"1.1.2 Testowanie a debugowanie",
        html:`<p>Testowanie i debugowanie to dwie różne czynności. Testowanie pozwala wywołać awarie, które są skutkiem defektów w oprogramowaniu (testowanie dynamiczne), lub znaleźć defekty bezpośrednio w przedmiocie testów (testowanie statyczne).</p>
        <p>Gdy w ramach testowania dynamicznego zostanie wywołana awaria, rozpoczyna się debugowanie, którego celem jest znalezienie przyczyn danej awarii (defektów), a następnie ich przeanalizowanie i wyeliminowanie. Typowy proces debugowania obejmuje:</p>
        <ul>
          <li>odtworzenie awarii,</li>
          <li>przeprowadzenie diagnozy (tj. znalezienie defektu),</li>
          <li>usunięcie defektu.</li>
        </ul>
        <p>Następnie wykonywane jest testowanie potwierdzające, które pozwala sprawdzić, czy wprowadzone poprawki doprowadziły do rozwiązania problemu. W optymalnych warunkach testowanie potwierdzające wykonuje osoba, która wcześniej przeprowadzała początkowy test. W dalszej kolejności można również wykonać testowanie regresji, aby upewnić się, że wprowadzone poprawki nie powodują awarii w innych obszarach przedmiotu testów.</p>
        <p>W przypadku wykrycia defektu podczas testowania statycznego debugowanie obejmuje usunięcie takiego defektu. Nie ma przy tym potrzeby odtwarzania ani diagnozowania problemu, ponieważ testowanie statyczne pozwala wykrywać defekty w sposób bezpośredni i nie może powodować awarii.</p>`,
        flashcards:[
          {q:"Czym różni się testowanie od debugowania?", a:"Testowanie wykrywa awarie/defekty; debugowanie diagnozuje i usuwa defekt, po czym wykonuje się testy potwierdzające (i regresję)."},
          {q:"Jakie są etapy debugowania?", a:"Odtworzenie awarii, diagnoza (znalezienie defektu), usunięcie defektu."},
          {q:"Co to jest testowanie potwierdzające?", a:"Test sprawdzający, czy wprowadzone poprawki rozwiązały problem - wykonuje najlepiej ta sama osoba, która wykryła awarię."}
        ],
      },
      {
        id:"1.2",
        title:"1.2 Dlaczego testowanie jest niezbędne?",
        html:`<p><b>Testowanie</b> — jako forma kontroli jakości — pomaga osiągnąć uzgodnione cele testów w określonym zakresie i czasie, z zachowaniem wymaganego poziomu jakości i budżetu. Wkład w wynik testów nie ogranicza się do zespołu testowego: w duchu podejścia „cały zespół" każdy interesariusz może wykorzystać swoje umiejętności, aby podnieść jakość produktu. Przetestowanie modułów, systemów i związanych z nimi produktów pracy (np. dokumentacji) umożliwia <b>identyfikację defektów</b> i redukcję ryzyka awarii.</p>
        <h4>1.2.1 Znaczenie testowania dla powodzenia projektu</h4>
        <p>Testowanie pozwala w opłacalny sposób <b>wykrywać defekty</b>, które następnie usuwa się poprzez debugowanie. Tym samym testowanie bezpośrednio i pośrednio podnosi jakość przedmiotu testów.</p>
        <ul>
          <li><b>Ocena jakości na różnych fazach SDLC</b> — wyniki testów są dostarczane iteracyjnie, dzięki czemu można mierzyć jakość od wczesnych etapów aż do przekazania do eksploatacji.</li>
          <li><b>Wsparcie decyzji zarządczych</b> — raporty z testów (postępu i sumaryczne) pomagają podejmować decyzje „go/no‑go" dotyczące wejścia w kolejną fazę lub wydanie produktu.</li>
          <li><b>Głos użytkownika</b> — testerzy wnoszą znajomość potrzeb użytkowników, zapewniając, że są one brane pod uwagę w całym cyklu. To alternatywa dla kosztownego stałego udziału szerokiej grupy użytkowników.</li>
          <li><b>Zgodność i regulacje</b> — w wielu domenach testowanie jest wymagane umowami, przepisami prawa lub normami/standardami branżowymi.</li>
        </ul>
        <h4>1.2.2 Testowanie a zapewnienie jakości</h4>
        <p>Często myli się <b>testowanie</b> z <b>zapewnieniem jakości (QA)</b>. To jednak <b>dwa różne procesy</b> uzupełniające się wzajemnie:</p>
        <ul>
          <li><b>Testowanie</b> to <i>kontrola jakości</i>, ukierunkowana na <b>produkt</b> i mająca charakter <b>korekcyjny</b>. Obejmuje uruchamianie testów dynamicznych oraz czynności statyczne, a także porównywanie wyników z oczekiwaniami i zgłaszanie defektów.</li>
          <li><b>Zapewnienie jakości</b> to podejście do <b>procesów</b> o charakterze <b>prewencyjnym</b>. Zakłada, że dobrze zaprojektowane i konsekwentnie stosowane procesy (standardy, polityki, przeglądy, metryki) prowadzą do tworzenia produktów lepszej jakości.</li>
          <li><b>Wyniki testów</b> służą obu obszarom: w kontroli jakości wspierają usuwanie defektów, a w QA dostarczają informacji zwrotnych o skuteczności procesów wytwarzania i testowania.</li>
        </ul>
        <h4>1.2.3 Pomyłki, defekty, awarie i podstawowe przyczyny</h4>
        <p><b>Pomyłka (błąd)</b> człowieka może spowodować <b>defekt</b> (usterkę) w artefakcie — wymaganiu, projekcie, kodzie czy danych konfiguracyjnych. Wykonanie wadliwego kodu może wywołać <b>awarię</b> (niezamierzone zachowanie). Nie każdy defekt zawsze ujawni się awarią; często dzieje się tak tylko w określonych warunkach.</p>
        <ul>
          <li><b>Źródła pomyłek</b>: presja czasu, złożoność systemu, złożone interakcje i środowiska, zmęczenie, niewystarczające szkolenie.</li>
          <li><b>Miejsca występowania defektów</b>: dokumentacja (np. wymagania, przypadki testowe), kod źródłowy, artefakty pomocnicze (np. pliki buildów, konfiguracje).</li>
          <li><b>Skutki nieusuniętych defektów</b>: propagacja na kolejne etapy SDLC i kosztowniejsze poprawki w późnej fazie.</li>
          <li><b>Inne przyczyny awarii</b>: czynniki środowiskowe (promieniowanie, zakłócenia elektromagnetyczne) mogą powodować nieprawidłowe działanie oprogramowania wbudowanego.</li>
        </ul>
        <p><b>Podstawowa przyczyna</b> to zasadniczy czynnik prowadzący do problemu. Jej identyfikacja następuje w trakcie <b>analizy przyczyny podstawowej</b> (root cause analysis) wykonywanej po awarii lub wykryciu defektu. Usunięcie przyczyny redukuje prawdopodobieństwo podobnych awarii w przyszłości.</p>`,
        flashcards:[
          {q:"Czym różni się testowanie od zapewnienia jakości?", a:"Testowanie to kontrola jakości produktu (korekcyjne); QA to podejście do procesów (prewencyjne)."},
          {q:"Wymień 3 źródła pomyłek w oprogramowaniu.", a:"Presja czasu, złożoność systemu, zmęczenie, niewystarczające szkolenie, złożone interakcje."},
          {q:"Co to jest podstawowa przyczyna?", a:"Zasadniczy czynnik prowadzący do problemu - jej usunięcie redukuje prawdopodobieństwo podobnych awarii."}
        ],
      },
      {
        id:"1.3",
        title:"1.3 Zasady testowania",
        html:`<p>Poniższe <b>siedem zasad testowania</b> stanowi uniwersalne wskazówki, które pomagają
        projektować, planować i wykonywać testy niezależnie od procesu i technologii. Zasady te nie są
        przepisami – należy stosować je świadomie, z uwzględnieniem ryzyka i kontekstu.</p>
        <ol>
          <li>
            <b>Testowanie ujawnia defekty, ale nie może dowieść ich braku.</b>
            <ul>
              <li>Wyniki testów <i>zmniejszają ryzyko</i> pozostawienia defektów, lecz nie dowodzą, że ich nie ma.</li>
              <li>Wysokie pokrycie i brak awarii to sygnał jakości, nie dowód poprawności produktu.</li>
              <li>Dlatego nie dążymy do „udowodnienia braku defektów", tylko do dostarczenia wiarygodnej informacji o jakości.</li>
            </ul>
          </li>
          <li>
            <b>Testowanie gruntowne jest niemożliwe.</b>
            <ul>
              <li>Pełna enumeracja danych wejściowych, ścieżek i kombinacji jest realna tylko w trywialnych przypadkach.</li>
              <li>Praktyka wymaga <b>priorytetyzacji</b>: techniki projektowania testów (rozdz. 4), dobór danych, <b>testowanie oparte na ryzyku</b> (5.2) oraz kryteria pokrycia.</li>
              <li>Ustalamy, <i>co</i> testować najpierw i <i>ile</i> dowodów jakości jest potrzebne do decyzji.</li>
            </ul>
          </li>
          <li>
            <b>Wczesne testowanie oszczędza czas i pieniądze.</b>
            <ul>
              <li>Defekty usunięte wcześnie nie propagują się do kolejnych artefaktów – koszt ich naprawy jest niższy.</li>
              <li>Rozpoczynamy <b>testowanie statyczne</b> (przeglądy, analiza) oraz przygotowanie testów dynamicznych jak najwcześniej.</li>
              <li>Wczesne informowanie o jakości skraca cykle i zmniejsza liczbę awarii po wdrożeniu.</li>
            </ul>
          </li>
          <li>
            <b>Defekty mogą się kumulować.</b>
            <ul>
              <li>Niewielka liczba modułów zawiera zwykle większość defektów (zasada Pareto).</li>
              <li>Wykorzystujemy wiedzę domenową, historię defektów i metryki, aby <b>skupić testy</b> na spodziewanych skupiskach.</li>
              <li>To naturalnie wspiera podejście oparte na ryzyku i optymalizuje nakład testów.</li>
            </ul>
          </li>
          <li>
            <b>Testy ulegają zużyciu.</b>
            <ul>
              <li>Wielokrotne uruchamianie tych samych testów zmniejsza szansę wykrycia nowych defektów.</li>
              <li>Potrzebna jest <b>pielęgnacja zestawu testów</b>: przeglądy, refaktoryzacja, dodawanie nowych przypadków i danych.</li>
              <li>Wyjątkiem jest <b>regresja automatyczna</b> – powtarzalna z definicji, ale również wymaga utrzymania.</li>
            </ul>
          </li>
          <li>
            <b>Testowanie zależy od kontekstu.</b>
            <ul>
              <li>Nie istnieje jedno uniwersalne podejście. Strategię i techniki dopasowujemy do <b>celów biznesowych, ryzyk i ograniczeń</b>.</li>
              <li>Przykłady: systemy krytyczne dla bezpieczeństwa wymagają surowszych kryteriów, a produkt konsumencki – silniejszego nacisku na użyteczność i szybkość iteracji.</li>
            </ul>
          </li>
          <li>
            <b>Przekonanie o braku defektów jest błędem.</b>
            <ul>
              <li>Nawet po usunięciu wszystkich wykrytych defektów produkt może <b>nie spełnić potrzeb użytkowników</b> lub oczekiwań biznesu.</li>
              <li>Oprócz weryfikacji („czy spełniamy specyfikację?") potrzebna jest <b>walidacja</b> („czy rozwiązujemy właściwy problem?") – testy akceptacyjne, eksploracyjne, scenariusze operacyjne.</li>
            </ul>
          </li>
        </ol>`,
        flashcards:[
          {q:"Podaj 3 z 7 zasad testowania.", a:"Np.: testy ujawniają defekty, a nie dowodzą ich braku; gruntowne testowanie jest niemożliwe; wczesne testowanie oszczędza czas/koszt; defekty się kumulują; testy się zużywają; testowanie zależy od kontekstu; złudzenie braku defektów."},
          {q:"Dlaczego testowanie gruntowne jest niemożliwe?", a:"Pełna enumeracja danych wejściowych, ścieżek i kombinacji jest realna tylko w trywialnych przypadkach - potrzebna priorytetyzacja."},
          {q:"Co oznacza zasada 'testy ulegają zużyciu'?", a:"Wielokrotne uruchamianie tych samych testów zmniejsza szansę wykrycia nowych defektów - potrzebna pielęgnacja zestawu testów."}
        ],
      },
      {
        id:"1.4",
        title:"1.4 Czynności testowe, testalia i role",
        html:`<p><b>Proces testowy</b> to powtarzalny zestaw czynności, które – dopasowane do kontekstu –
        maksymalizują szansę osiągnięcia celów testów. Poniżej znajduje się szczegółowy opis czynności,
        produktów pracy (testaliów), zależności kontekstowych oraz ról.</p>
        <h4>1.4.1 Czynności i zadania testowe</h4>
        <p>Czynności są zwykle iteracyjne i częściowo równoległe. Każda ma typowe wejścia, decyzje i wyjścia.</p>
        <h5>Planowanie testów – <i>co, po co i jak będziemy testować</i></h5>
        <ul>
          <li>Wejścia: kontekst produktu i projektu, wymagania/wizja, ograniczenia, ryzyka.</li>
          <li>Decyzje: cele testów, zakres i poziomy, <b>podejście/strategia</b>, typy i techniki testów, kryteria wejścia/wyjścia, metryki, narzędzia, role i odpowiedzialności, harmonogram i budżet.</li>
          <li>Wyjścia: <b>plan testów</b>, harmonogram, rejestr ryzyk, polityki jakości, plan danych i środowisk.</li>
        </ul>
        <h5>Monitorowanie i nadzór – <i>czy realizujemy plan</i></h5>
        <ul>
          <li>Monitorowanie: zbieranie metryk (wykonane/pozostałe przypadki, defekty, pokrycie, przepustowość, stan środowisk).</li>
          <li>Nadzór: działania korygujące (zmiana priorytetów, doszacowanie, usuwanie przeszkód, decyzje go/no‑go).</li>
          <li>Wyjścia: <b>raporty z postępu</b>, dyrektywy nadzorcze, aktualizacje planu.</li>
        </ul>
        <h5>Analiza testów – <i>co dokładnie należy sprawdzić</i></h5>
        <ul>
          <li>Przegląd podstawy testów (wymagania, historyjki, projekt, interfejsy) i przedmiotów testów.</li>
          <li>Identyfikacja <b>testowalnych cech</b> i związanych z nimi <b>warunków testowych</b> z uwzględnieniem ryzyk.</li>
          <li>Wczesne wyszukiwanie defektów w podstawie (raporty o defekcie) i ocena testowalności.</li>
          <li>Wyjścia: uszeregowane warunki testowe, wstępne kryteria pokrycia.</li>
        </ul>
        <h5>Projektowanie testów – <i>jak będziemy testować</i></h5>
        <ul>
          <li>Przekształcenie warunków w <b>przypadki testowe</b>, projekt danych wejściowych i rezultatów oczekiwanych z użyciem technik z rozdz. 4.</li>
          <li>Określenie wymagań na <b>dane testowe</b>, <b>środowiska</b> (konfiguracje, zaślepki/sterowniki, symulatory, wirtualizacja usług) i narzędzia.</li>
          <li>Wyjścia: przypadki i karty opisu testów, elementy pokrycia, specyfikacja środowiska i danych.</li>
        </ul>
        <h5>Implementacja testów – <i>przygotowanie do uruchomień</i></h5>
        <ul>
          <li>Budowa danych testowych, skryptów manualnych/automatycznych, procedur i <b>zestawów testowych</b>.</li>
          <li>Ustalenie priorytetów i kolejności przebiegów, przygotowanie harmonogramu i <b>gotowości środowisk</b>.</li>
          <li>Wyjścia: gotowe do uruchomienia testalia i skonfigurowane środowiska.</li>
        </ul>
        <h5>Wykonywanie testów – <i>uruchomienia i rejestracja wyników</i></h5>
        <ul>
          <li>Manualnie lub automatycznie, w wielu formach (ciągłe testowanie, testy w parach, sesje eksploracyjne).</li>
          <li>Porównanie <b>rezultatów rzeczywistych</b> z oczekiwanymi; rejestracja wyników i danych dowodowych.</li>
          <li>Analiza anomalii i zgłaszanie <b>defektów</b>, aktualizacja śledzenia powiązań.</li>
        </ul>
        <h5>Ukończenie testów – <i>zamknięcie i doskonalenie</i></h5>
        <ul>
          <li>Ocena kryteriów wyjścia, lista otwartych spraw (defekty, żądania zmian, backlog).</li>
          <li>Archiwizacja przydatnych testaliów, zamknięcie środowisk w uzgodnionym stanie.</li>
          <li><b>Retrospektywa</b> i wnioski na przyszłość; <b>sumaryczny raport z testów</b> dla interesariuszy.</li>
        </ul>
        <h4>1.4.2 Proces testowy w kontekście</h4>
        <p>Strategia i intensywność testów zależą od: interesariuszy i ich oczekiwań, umiejętności zespołu,
        krytyczności domeny i zidentyfikowanych ryzyk, architektury i technologii, ograniczeń projektu
        (zakres, budżet, terminy), kultury organizacyjnej, wybranego modelu wytwarzania oraz dostępnych
        narzędzi. Te czynniki determinują m.in. poziom automatyzacji, kryteria pokrycia, raportowanie,
        standardy dokumentacji oraz wymagany poziom niezależności testów.</p>
        <h4>1.4.3 Testalia</h4>
        <p><b>Testalia</b> to artefakty powstające podczas procesu testowego. Aby zachować spójność i
        możliwość audytu, należy stosować <b>zarządzanie konfiguracją</b>. Kluczowe kategorie:</p>
        <ul>
          <li><b>Planowanie</b>: plan testów, harmonogram, rejestr ryzyk, kryteria wejścia/wyjścia.</li>
          <li><b>Monitorowanie i nadzór</b>: raporty postępu, dyrektywy nadzorcze, aktualizacje ryzyka.</li>
          <li><b>Analiza</b>: uszeregowane warunki testowe, raporty o defektach w podstawie.</li>
          <li><b>Projektowanie</b>: przypadki, karty opisu, elementy pokrycia, wymagania na dane i środowiska.</li>
          <li><b>Implementacja</b>: procedury, skrypty automatyczne i manualne, zestawy, dane testowe,
            harmonogram uruchomień, elementy środowiska (zaślepki, sterowniki, symulatory, usługi wirtualne).</li>
          <li><b>Wykonywanie</b>: dzienniki testów, raporty o defektach, dowody wykonania.</li>
          <li><b>Ukończenie</b>: raport sumaryczny, lista działań doskonalących, zarchiwizowane testalia.</li>
        </ul>
        <h4>1.4.4 Śledzenie powiązań (traceability)</h4>
        <p>Utrzymuj powiązania między <b>podstawą testów</b> (wymagania, ryzyka) a <b>testaliami</b>
        (warunki, przypadki, zestawy), <b>wynikami</b> i <b>defektami</b> w całym cyklu. Korzyści:</p>
        <ul>
          <li>Ocena <b>pokrycia</b> i identyfikacja braków; definiowanie mierzalnych kryteriów pokrycia jako KPI.</li>
          <li>Analiza <b>wpływu zmian</b> – szybkie wskazanie przypadków do regresji.</li>
          <li>Przejrzyste raportowanie dla biznesu i ułatwione audyty zgodności.</li>
        </ul>
        <p>Przykłady KPI: odsetek wymagań pokrytych przypadkami, pokrycie ryzyk przypadkami,
        pokrycie elementów interfejsu/stanów, stopień realizacji zestawów o najwyższym priorytecie.</p>
        <h4>1.4.5 Role w testowaniu</h4>
        <p>Dwie podstawowe role:</p>
        <ul>
          <li><b>Zarządzanie testami</b> – odpowiedzialność za cały proces i zespół: planowanie, monitorowanie,
            nadzór, ukończenie, komunikacja z interesariuszami, decyzje jakościowe oraz rozwój praktyk.</li>
          <li><b>Testowanie</b> – odpowiedzialność techniczna: analiza, projektowanie, implementacja i wykonywanie
            testów, w tym automatyzacja i pielęgnacja testaliów.</li>
        </ul>
        <p>Kontekst determinuje podział zadań. W podejściach zwinnych część obowiązków zarządczych
        realizuje zespół, a funkcje przekrojowe (np. standardy, metryki, narzędzia) mogą pełnić <i>test managers</i>
        pracujący ponad zespołami. Pożądana jest odpowiednia <b>niezależność</b> przy zachowaniu ścisłej
        współpracy z wytwarzaniem.</p>`,
        flashcards:[
          {q:"Wymień 5 czynności testowych.", a:"Planowanie, monitorowanie/nadzór, analiza, projektowanie, implementacja, wykonywanie, ukończenie testów."},
          {q:"Co to są testalia?", a:"Produkty pracy powstające w procesie testowym: plany, przypadki testowe, dane, skrypty, raporty, środowiska."},
          {q:"Po co śledzić powiązania?", a:"Aby mierzyć pokrycie, oceniać ryzyko rezydualne, analizować wpływ zmian i przygotować audytowalne raporty."}
        ],
      },
      {
        id:"1.5",
        title:"1.5 Umiejętności i dobre praktyki",
        html:`<p><b>Niezbędne umiejętności</b> łączą wiedzę, praktykę i postawy. Dobry tester działa skutecznie
        zarówno technicznie, jak i w obszarze współpracy, zachowując dociekliwość oraz koncentrację na
        wartości biznesowej. Poniżej zebrano kluczowe kompetencje i praktyki.</p>
        <h4>1.5.1 Ogólne umiejętności wymagane w związku z testowaniem</h4>
        <ul>
          <li><b>Wiedza testerska</b>: techniki projektowania testów (czarno-/białoskrzynkowe, oparte na doświadczeniu), poziomy i typy testów, kryteria pokrycia, BDD/ATDD, testy potwierdzające i regresja, metryki.</li>
          <li><b>Staranność i metodyczność</b>: dbałość o szczegóły, systematyka w obserwacji, gotowość do replikacji i dokumentowania wyników – kluczowe przy defektach trudnych do uchwycenia.</li>
          <li><b>Umiejętności komunikacyjne</b>: klarowne raportowanie defektów (kroki, oczekiwane vs rzeczywiste, środowisko, dowody), aktywne słuchanie, dopasowanie języka do odbiorcy (biznes/technika).</li>
          <li><b>Myślenie analityczne i krytyczne</b>: formułowanie hipotez, rozumienie przyczyn i skutków, wykrywanie niespójności, świadomość uprzedzeń poznawczych (np. efekt potwierdzenia) i praca z faktami.</li>
          <li><b>Kreatywność</b>: generowanie różnorodnych scenariuszy, heurystyki eksploracyjne, poszukiwanie nietypowych ścieżek i danych.</li>
          <li><b>Wiedza techniczna</b>: podstawy architektury, API, DB/SQL, narzędzia CI/CD, wirtualizacja usług, analiza logów, podstawy skryptowania – by efektywniej dobierać testy i automatyzować.</li>
          <li><b>Wiedza domenowa</b>: zrozumienie procesów biznesowych i użytkowników; przekłada się na trafniejsze ryzyka i testy akceptacyjne.</li>
        </ul>
        <p>Komunikując wyniki testów, <b>unikaj obwiniania</b>. Zamiast ocen – fakty i wpływ biznesowy. To pomaga
        przełamać stereotyp „złych wiadomości" i buduje kulturę jakości.</p>
        <h4>1.5.2 Podejście „cały zespół" (whole‑team)</h4>
        <p>Jakość jest <b>wspólną odpowiedzialnością</b>. Kompetencje są wykorzystywane tam, gdzie są potrzebne,
        a role są płynne. Kluczowe praktyki:</p>
        <ul>
          <li><b>Wspólne definiowanie jakości</b>: kryteria akceptacji (np. Given/When/Then), Definition of Ready/Done, wspólne standardy raportowania defektów.</li>
          <li><b>Współpraca z biznesem</b>: doprecyzowanie potrzeb, tworzenie testów akceptacyjnych, priorytetyzacja ryzyk.</li>
          <li><b>Współpraca z programistami</b>: uzgodniona strategia testów, decyzje o automatyzacji (co na jakim poziomie), przeglądy i weryfikacja testowalności.</li>
          <li><b>Bliskość operacyjna</b>: wspólna przestrzeń (fizyczna/wirtualna), krótkie pętle informacji zwrotnej, sesje pairing/mobbing, trzy perspektywy „biznes‑dev‑test".</li>
          <li><b>Uwaga na wyjątki</b>: w systemach krytycznych może być wymagana <b>wyższa niezależność</b> testów i formalniejsze procesy.</li>
        </ul>
        <h4>1.5.3 Niezależność testowania</h4>
        <p>Różny poziom niezależności pomaga zmniejszyć efekt wspólnych uprzedzeń i dostarcza innej perspektywy,
        ale nie zastępuje znajomości produktu. Typowe poziomy i ich konsekwencje:</p>
        <ul>
          <li><b>Brak niezależności</b> – autor testuje własny produkt: szybka informacja zwrotna, lecz ryzyko ślepych punktów.</li>
          <li><b>Niezależność wewnątrz zespołu</b> – inni członkowie zespołu testują artefakty autora: kompromis szybkości i świeżego spojrzenia.</li>
          <li><b>Zespół testowy w organizacji</b> – wyższa niezależność, możliwość specjalizacji i standardów testowych.</li>
          <li><b>Jednostka zewnętrzna</b> – bardzo wysoka niezależność, przydatna w audytach/formalnych ocenach; koszt i czas mogą być większe.</li>
        </ul>
        <p><b>Korzyści</b>: inny profil wykrywanych awarii/defektów, weryfikacja założeń, większa wiarygodność wyników.
        <b>Ryzyka</b>: izolacja i gorsza wymiana informacji, możliwe „wąskie gardło". Rozwiązanie: jasne ustalenia
        odpowiedzialności, narzędzia współpracy, wspólne cele jakości.</p>`,
        flashcards:[
          {q:"Wymień 3 kluczowe umiejętności testera.", a:"Wiedza testerska, myślenie analityczne/krytyczne, umiejętności komunikacyjne, wiedza domenowa, kreatywność."},
          {q:"Co to jest podejście 'cały zespół'?", a:"Jakość jako wspólna odpowiedzialność - kompetencje wykorzystywane tam gdzie potrzebne, role płynne."},
          {q:"Wymień poziomy niezależności testowania.", a:"Brak niezależności, niezależność wewnątrz zespołu, zespół testowy w organizacji, jednostka zewnętrzna."}
        ],
      }
    ],
    quiz:[
      {q:"Który z poniższych jest celem testowania?", opt:["Udowodnienie braku defektów","Wykrycie defektów i ocena jakości","Zastąpienie debugowania","Eliminacja wszystkich awarii"], a:1, exp:"Testowanie ma na celu wykrycie defektów i ocenę jakości produktów pracy."},
      {q:"Czym różni się weryfikacja od walidacji?", opt:["Weryfikacja to testowanie dynamiczne, walidacja to statyczne","Weryfikacja sprawdza zgodność ze specyfikacją, walidacja - czy system odpowiada potrzebom użytkowników","Weryfikacja to debugowanie, walidacja to testowanie","To są synonimy"], a:1, exp:"Weryfikacja sprawdza zgodność ze specyfikacją, walidacja - czy system odpowiada potrzebom użytkowników i interesariuszy."},
      {q:"Które stwierdzenie o testowaniu jest prawdziwe?", opt:["Testowanie to tylko uruchamianie oprogramowania","Testowanie obejmuje planowanie, zarządzanie i monitorowanie","Testowanie zastępuje zapewnienie jakości","Testowanie nie wymaga myślenia"], a:1, exp:"Testowanie to zbiór czynności obejmujących planowanie, zarządzanie, szacowanie, monitorowanie i nadzór."},
      {q:"Co to jest testowanie potwierdzające?", opt:["Testowanie regresji","Testowanie sprawdzające czy poprawka rozwiązała problem","Testowanie statyczne","Testowanie niefunkcjonalne"], a:1, exp:"Testowanie potwierdzające sprawdza, czy wprowadzone poprawki rozwiązały problem."},
      {q:"Która z 7 zasad testowania mówi o niemożności gruntownego testowania?", opt:["Testy ujawniają defekty","Gruntowne testowanie jest niemożliwe","Wczesne testowanie oszczędza czas","Testowanie zależy od kontekstu"], a:1, exp:"Zasada 'gruntowne testowanie jest niemożliwe' wynika z faktu, że pełna enumeracja danych wejściowych i ścieżek jest nierealna."}
    ]
  },
  {
    id:"r2",
    title:"2. Testowanie w cyklu wytwarzania oprogramowania",
    read:`<h2>2. Testowanie w cyklu wytwarzania oprogramowania</h2>
      <p>Model SDLC wpływa na <b>czas/cel testów, techniki i automatyzację</b>. Poniżej pełny opis kluczowych zagadnień: modele i praktyki (TDD/ATDD/BDD, DevOps, <i>shift‑left</i>, retrospektywy), poziomy i typy testów, oraz testowanie pielęgnacyjne.</p>
      <h3>2.1 Testowanie w kontekście modelu cyklu wytwarzania oprogramowania</h3>
      <p>Model cyklu wytwarzania oprogramowania (ang. <b>software development lifecycle — SDLC</b>) stanowi abstrakcyjne, ogólne odwzorowanie procesu wytwarzania oprogramowania. Model ten określa wzajemne relacje — zarówno logiczne, jak i chronologiczne — między poszczególnymi fazami wytwarzania oprogramowania oraz rodzajami czynności wykonywanych w ramach tego procesu.</p>
      
      <p><b>Przykładami modeli cyklu wytwarzania oprogramowania są między innymi:</b></p>
      <ul>
        <li><b>Sekwencyjne modele wytwarzania oprogramowania</b> (np. model kaskadowy - ang. waterfall - lub model V)</li>
        <li><b>Iteracyjne modele wytwarzania oprogramowania</b> (np. model spiralny lub prototypowanie)</li>
        <li><b>Przyrostowe modele wytwarzania oprogramowania</b> (np. model Unified Process)</li>
      </ul>
      
      <p>Niektóre czynności wykonywane w ramach procesów wytwarzania oprogramowania można również opisać przy użyciu bardziej szczegółowych metod wytwarzania oprogramowania i praktyk zwinnych. <b>Przykładami są między innymi:</b></p>
      <ul>
        <li><b>Wytwarzanie sterowane testami akceptacyjnymi</b> (ang. acceptance test-driven development — ATDD)</li>
        <li><b>Wytwarzanie sterowane zachowaniem</b> (ang. behavior-driven development — BDD)</li>
        <li><b>Projektowanie oparte na domenie</b> (ang. domain-driven design — DDD)</li>
        <li><b>Programowanie ekstremalne</b> (ang. eXtreme Programming — XP)</li>
        <li><b>Wytwarzanie oparte na cechach</b> (ang. feature-driven development — FDD)</li>
        <li><b>Kanban, Lean IT, Scrum</b></li>
        <li><b>Wytwarzanie sterowane testami</b> (ang. test-driven development — TDD)</li>
      </ul>

      <h4>2.1.1 Wpływ cyklu wytwarzania oprogramowania na testowanie</h4>
      <p>Warunkiem powodzenia procesu testowania jest dopasowanie go do przyjętego cyklu wytwarzania oprogramowania. <b>Wybór modelu cyklu wytwarzania oprogramowania wpływa na:</b></p>
      <ul>
        <li>zakres i czas wykonywania czynności testowych (np. poziomy testów i typy testów)</li>
        <li>szczegółowość testaliów</li>
        <li>wybór technik testowania i podejścia do testowania</li>
        <li>zakres automatyzacji testów</li>
        <li>role i obowiązki testera</li>
      </ul>

      <p><b>W przypadku sekwencyjnych modeli wytwarzania oprogramowania:</b></p>
      <ul>
        <li>w początkowych fazach procesu testerzy uczestniczą zazwyczaj w przeglądach wymagań, analizie testów oraz projektowaniu testów</li>
        <li>kod wykonywalny powstaje z reguły w późniejszych fazach, co w większości przypadków uniemożliwia przeprowadzenie testowania dynamicznego na wczesnym etapie cyklu wytwarzania oprogramowania</li>
      </ul>

      <p><b>W niektórych iteracyjnych modelach wytwarzania i przyrostowych modelach wytwarzania:</b></p>
      <ul>
        <li>zakłada się, że w wyniku każdej iteracji powstaje działający prototyp lub kolejna wersja przyrostowa produktu</li>
        <li>oznacza to, że w każdej iteracji można wykonywać zarówno testowanie statyczne, jak i testowanie dynamiczne na wszystkich poziomach testów</li>
        <li>jednocześnie częste dostarczanie wersji przyrostowych wymaga szybkiego przekazywania informacji zwrotnych i szeroko zakrojonego testowania regresji</li>
      </ul>

      <p><b>W przypadku zwinnego wytwarzania oprogramowania:</b></p>
      <ul>
        <li>dopuszcza się wprowadzanie zmian przez cały czas trwania projektu</li>
        <li>z tego powodu w projektach zwinnych wskazane jest tworzenie uproszczonej dokumentacji produktów pracy i stosowanie na dużą skalę automatyzacji testów, co ułatwia testowanie regresji</li>
        <li>ponadto większość testowania manualnego wykonuje się zwykle przy użyciu technik testowania opartych na doświadczeniu, które nie wymagają wcześniejszego podjęcia szeroko zakrojonych działań związanych z analizą i projektowaniem testów</li>
      </ul>

      <h4>2.1.2 Model cyklu wytwarzania oprogramowania a dobre praktyki testowania</h4>
      <p>Poniżej wymieniono kilka dobrych praktyk testowania, które mają zastosowanie do każdego modelu cyklu wytwarzania oprogramowania:</p>
      <ul>
        <li><b>Do każdej czynności związanej z wytwarzaniem oprogramowania powinna być przypisana odpowiadająca jej czynność testowa</b>, tak aby wszystkie czynności związane z wytwarzaniem oprogramowania podlegały kontroli jakości</li>
        <li><b>Poszczególnym poziomom testów powinny odpowiadać konkretne i różne cele testów</b>, co pozwoli zapewnić odpowiednio szeroki zakres testów, a przy tym uniknąć nadmiarowości</li>
        <li><b>Aby zapewnić zgodność z zasadą wczesnego testowania</b>, analizę i projektowanie testów na potrzeby danego poziomu testów należy rozpocząć w odpowiadającej temu poziomowi fazie cyklu wytwarzania oprogramowania</li>
        <li><b>Testerzy powinni uczestniczyć w przeglądach produktów pracy natychmiast po udostępnieniu ich wersji roboczych</b>, tak aby wcześniejsze testowanie i wykrywanie defektów pomagało w realizacji przesunięcia w lewo</li>
      </ul>

      <h4>2.1.3 Testowanie jako czynnik określający sposób wytwarzania oprogramowania</h4>
      <p><b>Wytwarzanie sterowane testami (TDD), wytwarzanie sterowane testami akceptacyjnymi (ATDD) i wytwarzanie sterowane zachowaniem (BDD)</b> to podobne podejścia do wytwarzania oprogramowania, w ramach których testy traktuje się jako czynnik określający sposób prowadzenia prac programistycznych.</p>
      
      <p>Każde z tych podejść realizuje zasadę wczesnego testowania i przesunięcie w lewo, ponieważ testy są definiowane przed rozpoczęciem pisania kodu. Ponadto podejścia te umożliwiają stosowanie iteracyjnego modelu wytwarzania.</p>

      <p><b>Wytwarzanie sterowane testami (TDD):</b></p>
      <ul>
        <li>Zamiast rozbudowanych mechanizmów projektowania oprogramowania do określania sposobu tworzenia kodu wykorzystywane są przypadki testowe</li>
        <li>Najpierw pisane są testy, a dopiero potem powstaje kod umożliwiający ich pomyślne przejście. Następnie testy i kod podlegają refaktoryzacji</li>
      </ul>

      <p><b>Wytwarzanie sterowane testami akceptacyjnymi (ATDD):</b></p>
      <ul>
        <li>Testy są tworzone na podstawie kryteriów akceptacji w ramach procesu projektowania systemu</li>
        <li>Testy są pisane przed wytworzeniem części aplikacji, która ma je pomyślnie przejść</li>
      </ul>

      <p><b>Wytwarzanie sterowane zachowaniem (BDD):</b></p>
      <ul>
        <li>Pożądane zachowanie aplikacji wyraża się w postaci przypadków testowych napisanych w prostej formie języka naturalnego, która jest zrozumiała dla interesariuszy — zwykle w formacie Given/When/Then (Mając/Kiedy/Wtedy)</li>
        <li>Następnie przypadki testowe powinny być automatycznie przekładane na możliwe do wykonania testy</li>
      </ul>

      <p>W ramach wszystkich powyższych podejść testy mogą zostać zarejestrowane w postaci testów automatycznych, co pozwala zapewnić należytą jakość kodu w przypadku przyszłej adaptacji lub refaktoryzacji.</p>

      <h4>2.1.4 Metodyka DevOps a testowanie</h4>
      <p><b>DevOps to metodyka organizacyjna</b>, której celem jest uzyskanie efektu synergii poprzez ukierunkowanie działań związanych z wytwarzaniem oprogramowania (w tym z testowaniem) oraz działań związanych z jego eksploatacją na realizację szeregu wspólnych celów.</p>
      
      <p>Do wdrożenia tej metodyki niezbędna jest zmiana kultury organizacyjnej polegająca na wypełnieniu luki między strukturami odpowiedzialnymi za wytwarzanie (w tym testowanie) a strukturami odpowiedzialnymi za eksploatację przy jednoczesnym uznaniu, że zadania realizowane przez te struktury są równie istotne.</p>

      <p>DevOps sprzyja większej autonomii zespołów, szybszemu przekazywaniu informacji zwrotnych, ściślejszej integracji łańcuchów narzędzi oraz stosowaniu praktyk technicznych takich jak <b>ciągła integracja (ang. continuous integration — CI) i ciągłe dostarczanie (ang. continuous delivery — CD)</b>. Dzięki temu zespoły mogą szybciej tworzyć, testować i przekazywać do eksploatacji wysokiej jakości kod z wykorzystaniem potoku dostarczania DevOps.</p>

      <p><b>Z perspektywy testowania do korzyści ze stosowania metodyki DevOps można zaliczyć:</b></p>
      <ul>
        <li>szybkie otrzymywanie informacji zwrotnych na temat jakości kodu oraz ewentualnego niekorzystnego wpływu zmian na dotychczasowy kod</li>
        <li>ciągłą integrację, która sprzyja przesunięciu w lewo w obszarze testowania poprzez zachęcenie programistów do dostarczania wysokiej jakości kodu sprawdzonego testami modułowymi i analizą statyczną</li>
        <li>promowanie zautomatyzowanych procesów takich jak ciągła integracja i ciągłe dostarczanie, które ułatwiają tworzenie stabilnych środowisk testowych</li>
        <li>zwiększenie widoczności niefunkcjonalnych charakterystyk jakościowych (np. wydajności lub niezawodności)</li>
        <li>zmniejszenie zapotrzebowania na powtarzalne testowanie manualne dzięki automatyzacji, jaką zapewnia potok dostarczania</li>
        <li>zmniejszenie ryzyka związanego z regresją z uwagi na skalę i zasięg automatycznych testów regresji</li>
      </ul>

      <p><b>Z zastosowaniem metodyki DevOps wiążą się też pewne ryzyka i wyzwania, wśród których można wymienić:</b></p>
      <ul>
        <li>konieczność zdefiniowania i ustanowienia potoku dostarczania DevOps</li>
        <li>konieczność wprowadzenia i utrzymywania narzędzi do ciągłej integracji lub ciągłego dostarczania</li>
        <li>konieczność przeznaczenia dodatkowych zasobów na automatyzację testów oraz trudności związane z wprowadzeniem i utrzymaniem mechanizmów automatyzacji</li>
      </ul>

      <p>Chociaż metodyka DevOps zakłada duży udział testów automatycznych, nadal konieczne jest również testowanie manualne — zwłaszcza z perspektywy użytkownika.</p>

      <h4>2.1.5 Przesunięcie w lewo (ang. shift left approach)</h4>
      <p>Zasada wczesnego testowania jest niekiedy nazywana <b>"przesunięciem w lewo"</b>, ponieważ w myśl tej zasady testowanie odbywa się na wcześniejszym etapie cyklu wytwarzania oprogramowania. Przesunięcie w lewo sugeruje, że testowanie powinno odbywać się wcześniej (np. bez czekania na implementację kodu bądź integrację modułów), ale nie oznacza to, że należy zaniedbywać wykonywanie testów na dalszych etapach cyklu życia wytwarzania oprogramowania.</p>

      <p><b>Poniżej przedstawiono kilka dobrych praktyk, które obrazują, w jaki sposób można wdrożyć przesunięcie w lewo w testowaniu:</b></p>
      <ul>
        <li><b>dokonywanie przeglądu specyfikacji z punktu widzenia testerów</b> (przegląd specyfikacji pozwala często znaleźć potencjalne defekty, takie jak niejasności, braki czy niespójności)</li>
        <li><b>pisanie przypadków testowych przed rozpoczęciem pisania kodu i uruchamianie kodu w jarzmie testowym podczas implementacji</b></li>
        <li><b>korzystanie z mechanizmu ciągłej integracji (a jeszcze lepiej — ciągłego dostarczania)</b>, ponieważ mechanizm ten pozwala szybko uzyskiwać informacje zwrotne i wykonywać automatyczne testy modułowe w odniesieniu do kodu źródłowego przekazywanego do repozytorium kodu</li>
        <li><b>przeprowadzanie analizy statycznej kodu źródłowego przed rozpoczęciem testowania dynamicznego lub w ramach zautomatyzowanego procesu</b></li>
        <li><b>wykonywanie testowania niefunkcjonalnego już od poziomu testów modułowych wszędzie tam, gdzie jest to możliwe</b> (jest to forma przesunięcia w lewo, ponieważ testy niefunkcjonalne są często wykonywane na późniejszych etapach cyklu wytwarzania oprogramowania, gdy jest już dostępny kompletny system wraz z reprezentatywnym środowiskiem testowym)</li>
      </ul>

      <p>Przesunięcie w lewo może wymagać dodatkowych szkoleń, nakładów pracy i/lub kosztów na wcześniejszym etapie procesu, ale z założenia powinno to zostać zrekompensowane przez zmniejszenie nakładów pracy lub obniżenie kosztów na późniejszych etapach.</p>

      <p>W przypadku przesunięcia w lewo ważne jest przekonanie interesariuszy o zasadności takiego podejścia i uzyskanie ich poparcia w tym zakresie.</p>

      <h4>2.1.6 Retrospektywy i doskonalenie procesów</h4>
      <p><b>Retrospektywy są często organizowane</b> po zakończeniu projektu lub iteracji bądź osiągnięciu kamienia milowego związanego z przekazaniem do eksploatacji, ale w razie potrzeby mogą również odbywać się w innych momentach. Termin i przebieg retrospektywy zależy od przyjętego modelu cyklu wytwarzania oprogramowania.</p>

      <p>Podczas tego rodzaju spotkań uczestnicy (nie tylko testerzy, ale również np. programiści, architekci, właściciel produktu czy analitycy biznesowi) omawiają następujące kwestie:</p>
      <ul>
        <li>Jakie elementy zrealizowano pomyślnie i co należy zachować?</li>
        <li>Jakie działania zakończyły się niepowodzeniem i mogą zostać udoskonalone?</li>
        <li>W jaki sposób należy w przyszłości uwzględnić powyższe udoskonalenia i wykorzystać pomyślnie zrealizowane elementy?</li>
      </ul>

      <p>Rezultaty należy udokumentować — zwykle robi się to w ramach sumarycznego raportu z testów. Retrospektywy mają kluczowe znaczenie dla pomyślnej realizacji zasady ciągłego doskonalenia, dlatego ważne jest zweryfikowanie, czy zalecane usprawnienia zostały wprowadzone w życie.</p>

      <p><b>Typowe korzyści z punktu widzenia testowania to między innymi:</b></p>
      <ul>
        <li>zwiększenie skuteczności i efektywności testów (np. poprzez wprowadzenie w życie sugestii dotyczących doskonalenia procesów)</li>
        <li>podniesienie jakości testaliów (np. w wyniku wspólnego przeglądu procesów testowych)</li>
        <li>zacieśnienie więzi w zespole i wspólne uczenie się (np. dzięki możliwości zgłaszania problemów i proponowania usprawnień)</li>
        <li>podniesienie jakości podstawy testów (np. dzięki możliwości identyfikowania i usuwania niedociągnięć związanych z jakością i zakresem wymagań)</li>
        <li>usprawnienie współpracy między programistami a testerami (np. dzięki regularnemu weryfikowaniu i optymalizowaniu zasad współpracy)</li>
      </ul>
      <h3>2.2 Poziomy testów i typy testów</h3>
      <p><b>Poziomy testów</b> to grupy czynności testowych, które organizuje się i którymi zarządza się wspólnie. Każdy poziom testów jest instancją procesu testowego wykonywaną w odniesieniu do oprogramowania w danej fazie wytwarzania — od pojedynczych modułów po kompletne systemy lub, jeśli ma to zastosowanie w danym przypadku, po systemy systemów.</p>
      
      <p>Poziomy testów są powiązane z innymi czynnościami wykonywanymi w ramach cyklu wytwarzania oprogramowania. W sekwencyjnych modelach cyklu wytwarzania oprogramowania poziomy testów często definiuje się w taki sposób, aby kryteria wyjścia jednego poziomu były elementem kryteriów wejścia kolejnego poziomu, natomiast w niektórych modelach iteracyjnych zasada ta może nie mieć zastosowania. Czynności związane z wytwarzaniem oprogramowania mogą obejmować wiele poziomów testów, a poziomy testów mogą zachodzić na siebie w czasie.</p>

      <p><b>Typy testów</b> to grupy czynności testowych związanych z konkretnymi charakterystykami jakościowymi, przy czym większość z tych czynności można wykonywać na każdym poziomie testów.</p>

      <h4>2.2.1 Poziomy testów</h4>
      <p>W niniejszym sylabusie opisano pięć poziomów testów.</p>

      <p><b>• Testowanie modułowe</b> (zwane także testowaniem jednostkowym lub testowaniem komponentów) skupia się na oddzielnym testowaniu poszczególnych modułów. Często wymaga ono stosowania określonych elementów pomocniczych, takich jak jarzma testowe lub struktury do testów jednostkowych (ang. frameworks). Testowanie modułowe jest zwykle wykonywane przez programistów w środowiskach tworzenia oprogramowania.</p>

      <p><b>• Testowanie integracji modułów</b> (zwane także testowaniem połączenia) skupia się na interfejsach i interakcjach między modułami. Sposób testowania integracji modułów zależy w dużej mierze od strategii integracji — może to być na przykład strategia zstępująca, strategia wstępująca bądź strategia typu „wielki wybuch" (ang. big bang).</p>

      <p><b>• Testowanie systemowe</b> skupia się na ogólnym zachowaniu i możliwościach całego systemu lub produktu. Często obejmuje również kompleksowe testowanie funkcjonalne wszystkich zadań, jakie system ten może wykonywać, oraz testowanie niefunkcjonalne charakterystyk jakościowych. W przypadku niektórych niefunkcjonalnych charakterystyk jakościowych wskazane jest przeprowadzanie testów kompletnego systemu w reprezentatywnym środowisku testowym (np. testowanie użyteczności), ale można również zastosować symulacje podsystemów. Testowanie systemowe może być wykonywane przez niezależny zespół testowy i jest powiązane ze specyfikacjami systemu.</p>

      <p><b>• Testowanie integracji systemów</b> skupia się na interfejsach łączących system podlegający testowaniu z innymi systemami oraz usługami zewnętrznymi. Do testowania integracji systemów niezbędne są odpowiednie środowiska testowe — w miarę możliwości zbliżone do środowiska produkcyjnego.</p>

      <p><b>• Testowanie akceptacyjne</b> skupia się na przeprowadzeniu walidacji i wykazaniu, że system jest gotowy do wdrożenia (tzn. zaspokaja potrzeby biznesowe użytkownika). W idealnych warunkach testowanie akceptacyjne powinni przeprowadzać docelowi użytkownicy. Najważniejsze formy testowania akceptacyjnego to: testowanie akceptacyjne przez użytkownika, operacyjne testy akceptacyjne, testowanie akceptacyjne zgodności z umową i testowanie akceptacyjne zgodności z prawem, testowanie alfa oraz testowanie beta.</p>

      <p><b>Podstawą rozróżnienia między poszczególnymi poziomami testów</b> (w celu uniknięcia nakładania się czynności testowych) są między innymi następujące atrybuty:</p>
      <ul>
        <li>przedmiot testów</li>
        <li>cele testów</li>
        <li>podstawa testów</li>
        <li>defekty i awarie</li>
        <li>podejście i odpowiedzialności</li>
      </ul>

      <h4>2.2.2 Typy testów</h4>
      <p>Istnieje wiele typów testów, które można stosować w ramach projektów. W niniejszym sylabusie omówiono cztery z nich.</p>

      <p><b>Testowanie funkcjonalne</b> polega na dokonaniu oceny funkcji, które powinien realizować dany moduł lub system. Funkcje opisują to, „co" powinien robić dany przedmiot testów. Głównym celem testowania funkcjonalnego jest sprawdzenie kompletności funkcjonalnej, poprawności funkcjonalnej oraz adekwatności funkcjonalnej.</p>

      <p><b>Testowanie niefunkcjonalne</b> ma na celu dokonanie oceny atrybutów innych niż charakterystyki funkcjonalne modułu lub systemu. Testowanie niefunkcjonalne pozwala sprawdzić to, „jak dobrze" zachowuje się dany system. Głównym celem testowania niefunkcjonalnego jest sprawdzenie niefunkcjonalnych charakterystyk jakościowych.</p>

      <p><b>Standard ISO/IEC 25010 podaje następującą klasyfikację niefunkcjonalnych charakterystyk jakościowych:</b></p>
      <ul>
        <li>wydajność działania</li>
        <li>kompatybilność</li>
        <li>użyteczność (znana również jako zdolność do interakcji)</li>
        <li>niezawodność</li>
        <li>zabezpieczenia</li>
        <li>utrzymywalność</li>
        <li>przenaszalność (znana również jako elastyczność)</li>
        <li>bezpieczeństwo</li>
      </ul>

      <p>W pewnych przypadkach wskazane jest rozpoczęcie testowania niefunkcjonalnego na wczesnym etapie cyklu wytwarzania (np. w ramach przeglądów oraz testowania modułowego lub systemowego). Podstawą wielu testów niefunkcjonalnych są testy funkcjonalne — w praktyce wykorzystywane są te same testy funkcjonalne, ale celem jest sprawdzenie, czy podczas wykonywania danej funkcji spełniane są wymogi niefunkcjonalne (np. czy funkcja jest wykonywana w określonym czasie lub czy można ją przenieść na nową platformę). Zbyt późne wykrycie defektów odnoszących się do charakterystyk niefunkcjonalnych może być bardzo dużym zagrożeniem dla powodzenia projektu. Do wykonania testowania niefunkcjonalnego może być niekiedy niezbędne bardzo konkretne środowisko testowe, takie jak laboratorium użyteczności w przypadku testowania użyteczności.</p>

      <p><b>Testowanie czarnoskrzynkowe</b> (patrz podrozdział 4.2) opiera się na specyfikacjach, a testy wyprowadza się na podstawie dokumentacji niezwiązanej z wewnętrzną strukturą przedmiotu testów. Głównym celem testowania czarnoskrzynkowego jest sprawdzenie zachowania systemu pod kątem zgodności ze specyfikacją.</p>

      <p><b>Testowanie białoskrzynkowe</b> (patrz podrozdział 4.3) ma charakter strukturalny, a testy wyprowadza się na podstawie implementacji lub struktury wewnętrznej danego systemu (np. kodu, architektury, przepływów pracy i przepływów danych). Głównym celem testowania białoskrzynkowego jest uzyskanie akceptowalnego poziomu pokrycia testowego bazowej struktury systemu.</p>

      <p>Wszystkie cztery typy testów wymienione powyżej można stosować na wszystkich poziomach testów, chociaż działania podejmowane na każdym z tych poziomów będą inaczej ukierunkowane. Do wyprowadzania warunków testowych i przypadków testowych na potrzeby wszystkich wspomnianych typów testów można używać różnych technik testowania.</p>

      <h4>2.2.3 Testowanie potwierdzające i testowanie regresji</h4>
      <p>W modułach lub systemach są często wprowadzane zmiany mające na celu rozszerzenie funkcjonalności poprzez dodanie nowego elementu bądź przywrócenie prawidłowej funkcjonalności poprzez usunięcie defektu. Oznacza to, że proces testowania powinien również obejmować testowanie potwierdzające i testowanie regresji.</p>

      <p><b>Testowanie potwierdzające</b> ma na celu sprawdzenie, czy pierwotny defekt został pomyślnie usunięty. Zależnie od poziomu ryzyka skorygowaną wersję oprogramowania można przetestować na kilka sposobów, w tym poprzez:</p>
      <ul>
        <li>wykonanie wszystkich przypadków testowych, które wcześniej nie zostały zaliczone z powodu defektu lub</li>
        <li>dodanie nowych testów w celu pokrycia ewentualnych zmian, które były niezbędne do usunięcia defektu</li>
      </ul>

      <p>Jeśli jednak przy usuwaniu defektów brakuje czasu lub środków finansowych, testowanie potwierdzające można ograniczyć do wykonania kroków testowych potrzebnych do odtworzenia awarii spowodowanej defektem i sprawdzenia, czy tym razem ona nie występuje.</p>

      <p><b>Testowanie regresji</b> pozwala sprawdzić, czy wprowadzona zmiana (w tym także poprawka, która była już przedmiotem testowania potwierdzającego) nie spowodowała negatywnych konsekwencji. Konsekwencje takie mogą dotyczyć modułu, w którym wprowadzono zmianę, innych modułów tego samego systemu, a nawet innych podłączonych systemów, w związku z czym testowanie regresji może wykraczać poza przedmiot testów i obejmować również środowisko, w którym się on znajduje. Dlatego zalecane jest wykonywanie w pierwszej kolejności analizy wpływu mającej na celu zoptymalizowanie zasięgu testowania regresji, co pozwoli wskazać elementy oprogramowania, na które będzie mogła wpłynąć wprowadzona zmiana.</p>

      <p>Zestawy testów regresji są wykonywane wielokrotnie, a liczba związanych z nimi przypadków testowych rośnie z każdą iteracją lub każdą wersją, w związku z czym testowanie regresji świetnie nadaje się do automatyzacji. Dlatego też automatyzację tego rodzaju testów należy rozpocząć na początkowym etapie projektu. Automatyzacja testów regresji jest również dobrą praktyką w przypadku korzystania z mechanizmu ciągłej integracji — na przykład w ramach metodyki DevOps (patrz sekcja 2.1.4). Zależnie od sytuacji, automatyzacja ta może obejmować testy regresji na różnych poziomach testów.</p>

      <p>Testowanie potwierdzające i/lub testowanie regresji należy wykonywać w odniesieniu do przedmiotu testów na wszystkich poziomach testów, na których zostały usunięte defekty i/lub wprowadzone zmiany.</p>
      <h3>2.3 Testowanie pielęgnacyjne</h3>
      <p>Wyróżnia się kilka kategorii testowania pielęgnacyjnego. <b>Pielęgnacja może obejmować między innymi:</b></p>
      <ul>
        <li>działania naprawcze</li>
        <li>działania wynikające z konieczności dostosowania oprogramowania do zmian w środowisku</li>
        <li>działania mające na celu zwiększenie wydajności lub utrzymywalności</li>
      </ul>
      
      <p>(Szczegółowe informacje na ten temat zawiera standard <b>ISO/IEC 14764</b>).</p>

      <p>Tym samym <b>testowanie pielęgnacyjne może wynikać z wdrożenia oprogramowania lub przekazania go do eksploatacji zarówno w sposób planowy, jak i niezaplanowany</b> — na przykład w związku z poprawkami doraźnymi (ang. hot fix).</p>

      <p><b>Przed dokonaniem zmiany można przeprowadzić analizę wpływu</b>, aby ustalić, czy zmianę tę należy faktycznie wprowadzić (z uwagi na potencjalne konsekwencje w innych obszarach systemu). Ponadto jeśli dany system znajduje się w eksploatacji, testowanie zmian obejmuje zarówno sprawdzenie, czy zmiana została wprowadzona pomyślnie, jak i wykrycie ewentualnych regresji w niezmienionych częściach systemu (czyli zwykle w większości jego obszarów).</p>

      <p><b>Na zakres testowania pielęgnacyjnego wpływają zwykle:</b></p>
      <ul>
        <li>poziom ryzyka związanego ze zmianą</li>
        <li>wielkość dotychczasowego systemu</li>
        <li>wielkość wprowadzonej zmiany</li>
      </ul>

      <p><b>Zdarzenia wywołujące pielęgnację i testowanie pielęgnacyjne można podzielić na następujące kategorie:</b></p>

      <p><b>• Modyfikacje.</b> Ta kategoria obejmuje między innymi zaplanowane udoskonalenia (wprowadzane w postaci nowych wersji oprogramowania), zmiany korekcyjne i poprawki doraźne.</p>

      <p><b>• Uaktualnienia lub migracje środowiska produkcyjnego.</b> Ta kategoria obejmuje między innymi przejście z jednej platformy na inną, co może wiązać się z koniecznością przeprowadzenia testów związanych z nowym środowiskiem i zmienionym oprogramowaniem bądź testów konwersji danych (w przypadku migracji danych z innej aplikacji do pielęgnowanego systemu).</p>

      <p><b>• Wycofanie.</b> Ta kategoria dotyczy sytuacji, w której okres użytkowania aplikacji dobiega końca. W przypadku wycofywania systemu może być konieczne przetestowanie archiwizacji danych, jeśli zachodzi potrzeba ich przechowywania przez dłuższy czas. Ponadto jeśli w okresie archiwizacji będzie wymagany dostęp do niektórych danych, może być konieczne przetestowanie procedur przywracania i odtwarzania danych po archiwizacji.</p>`,
    flashcards:[
      {q:"Wymień 5 poziomów testów z sylabusa.", a:"Modułowe, integracja modułów, systemowe, integracja systemów, akceptacyjne."},
      {q:"Czym różni się test potwierdzający od regresji?", a:"Potwierdzający sprawdza, czy usunięty defekt zniknął; regresja – czy zmiany nie zepsuły obszarów niezmienianych (może być szeroka)."},
      {q:"Na czym polega shift‑left?", a:"Przesunięcie aktywności testowych wcześniej w SDLC: przeglądy, analiza statyczna, pisanie testów przed kodem, CI."},
      {q:"Wpływ DevOps na testowanie w 2 punktach.", a:"Szybka informacja zwrotna + automatyzacja (CI/CD), stabilniejsze środowiska; nadal potrzebne testy manualne użytkownika."}
    ],
    quiz:[
      {q:"Który poziom następuje bezpośrednio po testowaniu systemowym?", opt:["Modułowe","Integracja modułów","Integracja systemów","Akceptacyjne"], a:2},
      {q:"Które twierdzenie o DevOps jest prawdziwe?", opt:["Eliminuje testy manualne","Wymaga CI/CD i zwiększa automatyzację","Dotyczy tylko operacji","Nie łączy się z shift‑left"], a:1},
      {q:"Który zestaw to <i>typy</i> testów, a nie poziomy?", opt:["Funkcjonalne, niefunkcjonalne, białoskrzynkowe","Modułowe, integracja, systemowe","Modułowe, akceptacyjne, UAT","Integracja systemów, integracja modułów"], a:0},
      {q:"Najlepsza definicja shift‑left?", opt:["Przenosimy testy z UAT do produkcji","Wcześniejsze uruchamianie przeglądów i testów","Testujemy tylko manualnie","Zwiększamy liczbę testów E2E"], a:1},
      {q:"Testy potwierdzające …", opt:["to to samo co regresja","sprawdzają konkretną poprawkę","zawsze obejmują pełny system","są wyłącznie automatyczne"], a:1},
      {q:"Które stwierdzenie o TDD jest prawdziwe?", opt:["TDD to testowanie po napisaniu kodu","TDD to pisanie testów przed kodem","TDD to tylko testy jednostkowe","TDD eliminuje potrzebę testowania manualnego"], a:1, exp:"TDD (Test-Driven Development) to pisanie testów przed napisaniem kodu implementującego funkcjonalność."},
      {q:"Co to jest testowanie pielęgnacyjne?", opt:["Testowanie nowych funkcji","Testowanie istniejącego oprogramowania po zmianach","Testowanie tylko w produkcji","Testowanie tylko automatyczne"], a:1, exp:"Testowanie pielęgnacyjne to testowanie istniejącego oprogramowania po wprowadzeniu zmian."},
      {q:"Który model SDLC jest sekwencyjny?", opt:["Model spiralny","Model kaskadowy (waterfall)","Scrum","Kanban"], a:1, exp:"Model kaskadowy (waterfall) to przykład sekwencyjnego modelu SDLC."},
      {q:"Co oznacza ATDD?", opt:["Automated Test-Driven Development","Acceptance Test-Driven Development","Agile Test-Driven Development","Advanced Test-Driven Development"], a:1, exp:"ATDD to Acceptance Test-Driven Development - wytwarzanie sterowane testami akceptacyjnymi."},
      {q:"Które testy są wykonywane na najniższym poziomie?", opt:["Testy systemowe","Testy integracji modułów","Testy modułowe","Testy akceptacyjne"], a:2, exp:"Testy modułowe są wykonywane na najniższym poziomie, testując pojedyncze komponenty."}
    ]
  },
  {
    id:"r3",
    title:"3. Testowanie statyczne",
    read:`<h2>3. Testowanie statyczne</h2>
      <h3>3.1 Podstawy testowania statycznego</h3>
      <p>W przeciwieństwie do testowania dynamicznego <b>testowanie statyczne nie wymaga uruchamiania testowanego oprogramowania</b>. W testowaniu statycznym oceny kodu, specyfikacji procesów, specyfikacji architektury systemu i innych produktów pracy dokonuje się poprzez ich manualne zbadanie (np. w ramach przeglądu) lub poprzez zastosowanie odpowiedniego narzędzia (np. w ramach analizy statycznej).</p>

      <p>Wśród celów testowania statycznego można wymienić <b>podnoszenie jakości, wykrywanie defektów oraz ocenianie charakterystyk takich jak czytelność, kompletność, poprawność, testowalność czy spójność</b>. Testowanie statyczne można stosować zarówno w przypadku weryfikacji, jak i w przypadku walidacji.</p>

      <p><b>Testerzy, przedstawiciele jednostek biznesowych (właściciele produktu, analitycy biznesowi, itp.) i programiści współpracują ze sobą</b> podczas sesji mapowania przykładów (ang. example mapping), wspólnego pisania historyjek użytkownika i doprecyzowywania backlogu (ang. backlog refinement sessions), dbając o to, aby historyjki użytkownika i związane z nimi produkty pracy były zgodne z określonymi kryteriami — na przykład z definicją gotowości (ang. Definition of Ready, patrz sekcja 5.1.3).</p>

      <p>Mogą oni przy tym korzystać z technik przeglądu, aby zyskać pewność, że tworzone historyjki użytkownika są kompletne i zrozumiałe oraz zawierają testowalne kryteria akceptacji. <b>Zadając właściwe pytania, testerzy mogą również badać, kwestionować i udoskonalać proponowane historyjki użytkownika.</b></p>

      <p><b>Analiza statyczna pozwala rozpoznać problemy przed rozpoczęciem testowania dynamicznego</b>, a przy tym jest często mniej pracochłonna, ponieważ nie wymaga tworzenia przypadków testowych i odbywa się zwykle z wykorzystaniem narzędzi (patrz rozdział 6). Często jest też elementem mechanizmów ciągłej integracji (patrz sekcja 2.1.4).</p>

      <p>Chociaż głównym zastosowaniem analizy statycznej jest wykrywanie konkretnych defektów kodu, metoda ta może również służyć do oceny utrzymywalności i poziomu zabezpieczenia systemu. <b>Przykładami narzędzi do analizy statycznej są również narzędzia do sprawdzania pisowni i czytelności.</b></p>

      <h4>3.1.1 Produkty pracy badane metodą testowania statycznego</h4>
      <p>Przy użyciu technik testowania statycznego można zbadać niemal wszystkie produkty pracy, na przykład:</p>
      <ul>
        <li>dokumenty zawierające specyfikacje wymagań</li>
        <li>kod źródłowy</li>
        <li>plany testów</li>
        <li>przypadki testowe</li>
        <li>pozycje backlogu (ang. product backlog items)</li>
        <li>karty opisu testów</li>
        <li>dokumentację projektu</li>
        <li>umowy</li>
        <li>modele</li>
      </ul>

      <p>Należy jednak pamiętać, że o ile przedmiotem przeglądu może być dowolny produkt pracy, który da się przeczytać i zrozumieć, o tyle w przypadku analizy statycznej niezbędna jest struktura (np. modele, kod lub tekst z formalną składnią), względem której można sprawdzić badane produkty pracy.</p>

      <p><b>Do produktów pracy, które nie nadają się do objęcia testowaniem statycznym, należą między innymi:</b></p>
      <ul>
        <li>produkty trudne do zinterpretowania przez człowieka</li>
        <li>produkty, których nie należy analizować za pomocą narzędzi (np. kod wykonywalny innych firm, którego nie wolno badać ze względów prawnych)</li>
      </ul>

      <h4>3.1.2 Korzyści wynikające z testowania statycznego</h4>
      <p><b>Testowanie statyczne pozwala wykryć defekty w najwcześniejszych fazach cyklu wytwarzania oprogramowania</b>, a tym samym realizuje zasadę wczesnego testowania (patrz podrozdział 1.3). Ponadto metoda ta umożliwia identyfikowanie defektów, których nie da się wykryć podczas testowania dynamicznego — takich jak nieosiągalny kod, niewłaściwie zaimplementowane wzorce projektowe czy defekty w niewykonywalnych produktach pracy.</p>

      <p><b>Testowanie statyczne umożliwia dokonywanie oceny jakości produktów pracy i budowanie zaufania do nich.</b> Weryfikując udokumentowane wymagania, interesariusze mogą upewnić się, że opisują one ich rzeczywiste potrzeby. Ponadto — z uwagi na fakt, że testowanie statyczne można wykonywać we wczesnych fazach cyklu wytwarzania oprogramowania — zaangażowani w ten proces interesariusze mogą wypracować wspólny punkt widzenia.</p>

      <p><b>Inną ważną korzyścią jest usprawnienie wymiany informacji pomiędzy interesariuszami.</b> Z tego powodu zaleca się, aby w proces testowania statycznego zaangażowane było możliwie szerokie grono zainteresowanych osób.</p>

      <p>Chociaż przeprowadzanie przeglądów może być kosztowne, łączne koszty projektu są zwykle dużo niższe niż w przypadku rezygnacji z tego procesu, ponieważ dzięki przeglądom zmniejsza się czasochłonność i pracochłonność usuwania defektów na późniejszych etapach projektu.</p>

      <p><b>Analiza statyczna pozwala wykrywać określone defekty kodu bardziej efektywnie niż testowanie dynamiczne</b>, co przekłada się zwykle na zmniejszenie liczby tego rodzaju defektów oraz obniżenie łącznych nakładów pracy związanych z wytwarzaniem oprogramowania.</p>

      <h4>3.1.3 Różnice między testowaniem statycznym a dynamicznym</h4>
      <p>Testowanie statyczne i testowanie dynamiczne wzajemnie się uzupełniają. Techniki te mają podobne cele, takie jak wspomaganie wykrywania defektów w produktach pracy (patrz sekcja 1.1.1), ale różnią się pod pewnymi względami, które opisano poniżej.</p>

      <ul>
        <li><b>Zarzówno testowanie statyczne, jak i testowanie dynamiczne (z analizą awarii) może prowadzić do wykrycia defektów, jednak istnieją pewne rodzaje defektów, które można wykryć tylko jedną z powyższych metod.</b></li>
        <li><b>Testowanie statyczne umożliwia bezpośrednie wykrywanie defektów, natomiast testowanie dynamiczne powoduje występowanie awarii, które są następnie analizowane w celu zidentyfikowania związanych z nimi defektów.</b></li>
        <li><b>Testowanie statyczne pozwala łatwiej wykryć defekty, które znajdują się na rzadko wykonywanych ścieżkach w kodzie lub w miejscach trudno dostępnych podczas testowania dynamicznego.</b></li>
        <li><b>Testowanie statyczne można stosować do niewykonywalnych produktów pracy, a testowanie dynamiczne — tylko do produktów pracy wykonywalnych.</b></li>
        <li><b>Testowanie statyczne może służyć do mierzenia charakterystyk jakościowych, które nie są zależne od wykonywania kodu (takich jak utrzymywalność), a testowanie dynamiczne — do mierzenia charakterystyk jakościowych zależnych od wykonywania kodu (takich jak wydajność).</b></li>
      </ul>

      <p><b>Przykładami typowych defektów, które są łatwiejsze i/lub tańsze do wykrycia przy zastosowaniu metody testowania statycznego, są między innymi:</b></p>

      <p><b>• Defekty w wymaganiach</b> (np. niespójności, niejednoznaczności, sprzeczności, przeoczenia, nieścisłości czy powtórzenia)</p>

      <p><b>• Defekty w projekcie</b> (np. nieefektywne struktury baz danych bądź niewłaściwa modularyzacja)</p>

      <p><b>• Niektóre typy defektów w kodzie</b> (np. zmienne z niezdefiniowanymi wartościami, niezadeklarowane zmienne, nieosiągalny lub wielokrotnie powtórzony kod bądź kod o nadmiernej złożoności)</p>

      <p><b>• Odchylenia od standardów</b> (np. brak zgodności z konwencjami nazewnictwa określonymi w standardach tworzenia kodu)</p>

      <p><b>• Niepoprawne specyfikacje interfejsów</b> (np. niezgodność liczby, typu lub kolejności parametrów)</p>

      <p><b>• Określone rodzaje słabych punktów zabezpieczeń</b> (np. podatność na przepełnienie bufora)</p>

      <p><b>• Luki lub nieścisłości w pokryciu podstawy testów</b> (np. brak testów odpowiadających kryteriom akceptacji)</p>
      <h3>3.2 Informacje zwrotne i proces przeglądu</h3>

      <h4>3.2.1 Korzyści wynikające z wczesnego i częstego otrzymywania informacji zwrotnych od interesariuszy</h4>
      <p><b>Przekazywane w odpowiednim czasie i z odpowiednią częstotliwością informacje zwrotne umożliwiają wczesne rozpoznawanie i sygnalizowanie potencjalnych problemów z jakością.</b> Jeśli zaangażowanie interesariuszy w trakcie cyklu wytwarzania oprogramowania jest niewielkie, wytwarzany produkt może okazać się niezgodny z ich pierwotną lub obecną wizją.</p>

      <p><b>Niespełnienie oczekiwań interesariuszy może mieć poważne konsekwencje, takie jak:</b></p>
      <ul>
        <li>konieczność wprowadzenia kosztownych poprawek</li>
        <li>niedotrzymanie terminów</li>
        <li>przerzucanie się odpowiedzialnością</li>
        <li>a nawet niepowodzenie całego projektu</li>
      </ul>

      <p><b>Częste przekazywanie przez interesariuszy informacji zwrotnych we wszystkich fazach cyklu wytwarzania oprogramowania pozwala:</b></p>
      <ul>
        <li>zapobiec ewentualnym nieporozumieniom w kwestii wymagań</li>
        <li>umożliwić szybsze analizowanie i wprowadzanie ewentualnych zmian</li>
        <li>dysponować lepszą wiedzą na temat budowanego systemu</li>
        <li>skoncentrować się na działaniach, które przynoszą interesariuszom największe korzyści</li>
        <li>najskuteczniej łagodzić zidentyfikowane ryzyka</li>
      </ul>

      <h4>3.2.2 Czynności wykonywane w procesie przeglądu</h4>
      <p>W standardzie <b>ISO/IEC 20246</b> zdefiniowano ogólny proces przeglądu, który wyznacza usystematyzowane, a zarazem elastyczne ramy będące podstawą do wypracowania szczegółowego procesu dostosowanego do konkretnej sytuacji. Jeśli wymagany przegląd ma charakter bardziej formalny, konieczne jest wykonanie większej liczby zadań opisanych w kontekście poszczególnych czynności.</p>

      <p>Wiele produktów pracy ma zbyt duże rozmiary, aby można je było objąć pojedynczym przeglądem. W takiej sytuacji w celu przeanalizowania całego produktu pracy proces przeglądu można przeprowadzić wielokrotnie.</p>

      <p><b>W procesie przeglądu można wyróżnić następujące czynności:</b></p>

      <p><b>• Planowanie.</b> W fazie planowania określa się zakres przeglądu, w tym cel przeglądu, produkt pracy będący jego przedmiotem, oceniane charakterystyki jakościowe, obszary wymagające szczególnej uwagi, kryteria wyjścia, informacje pomocnicze (takie jak standardy), nakład pracy oraz ramy czasowe.</p>

      <p><b>• Rozpoczęcie przeglądu.</b> Na etapie rozpoczęcia przeglądu należy upewnić się, że wszystkie zaangażowane osoby i wszystkie niezbędne elementy są gotowe do jego wykonania. Należy między innymi sprawdzić, czy każdy uczestnik ma dostęp do produktu pracy będącego przedmiotem przeglądu, zna swoją rolę i swoje obowiązki oraz otrzymał wszystkie materiały niezbędne do przeprowadzenia przeglądu.</p>

      <p><b>• Przegląd indywidualny.</b> Każdy przeglądający dokonuje przeglądu indywidualnego, aby ocenić jakość produktu pracy będącego przedmiotem przeglądu oraz zidentyfikować ewentualne anomalie, zalecenia i pytania, korzystając w tym celu z jednej lub kilku technik przeglądu (takich jak przegląd oparty na liście kontrolnej czy przegląd oparty na scenariuszach). Dokładniejsze informacje na temat poszczególnych technik przeglądu zawiera standard ISO/IEC 20246. Przeglądający odnotowują wszystkie zidentyfikowane przez siebie anomalie, zalecenia i pytania.</p>

      <p><b>• Przekazanie informacji i analiza.</b> Z uwagi na to, że anomalie zidentyfikowane w trakcie przeglądu nie muszą być defektami, konieczne jest przeanalizowanie i omówienie każdej z nich, a następnie określenie jej statusu, wyznaczenie osoby odpowiedzialnej i wskazanie wymaganych działań. Zwykle odbywa się to w ramach spotkania związanego z przeglądem, podczas którego uczestnicy podejmują również decyzję co do poziomu jakości produktu pracy będącego przedmiotem przeglądu oraz wymaganych dalszych działań. Może się również okazać, że zakończenie podjętych działań będzie wymagało zorganizowania kolejnego przeglądu.</p>

      <p><b>• Usunięcie defektów i raportowanie.</b> W odniesieniu do każdego defektu należy sporządzić raport o defekcie, aby umożliwić zweryfikowanie wykonania działań naprawczych. Po spełnieniu kryteriów wyjścia można dokonać odbioru produktu pracy. Wyniki przeglądu należy ująć w raporcie.</p>

      <h4>3.2.3 Role i obowiązki w przeglądach</h4>
      <p>W przeglądach uczestniczą różni interesariusze, którzy mogą pełnić kilka ról. Poniżej omówiono najważniejsze role i związane z nimi odpowiedzialności:</p>

      <p><b>• Kierownik</b> — decyduje o tym, co ma być przedmiotem przeglądu, a także udostępnia niezbędne zasoby — w tym wyznacza pracowników oraz określa ramy czasowe przeglądu.</p>

      <p><b>• Autor</b> — tworzy produkt pracy będący przedmiotem przeglądu i usuwa występujące w nim defekty.</p>

      <p><b>• Moderator</b> (zwany także facylitatorem) — dba o sprawny przebieg spotkań związanych z przeglądem. Występuje w roli mediatora, zarządza czasem oraz zapewnia bezpieczne warunki, w których każdy uczestnik przeglądu może swobodnie wyrażać swoje zdanie.</p>

      <p><b>• Protokolant</b> (zwany także rejestrującym) — gromadzi informacje o anomaliach przekazane przez przeglądających takie jak decyzje i nowe anomalie znalezione podczas spotkania przeglądowego i protokołuje informacje związane z przeglądem, w tym informacje o podjętych decyzjach oraz o nowych anomaliach stwierdzonych w trakcie spotkania związanego z przeglądem.</p>

      <p><b>• Przeglądający</b> — wykonuje przegląd. Rolę tę może pełnić osoba pracująca przy projekcie, ekspert merytoryczny lub dowolny inny interesariusz.</p>

      <p><b>• Lider przeglądu</b> — ponosi ogólną odpowiedzialność za przegląd, w tym decyduje o tym, kto ma wziąć udział w przeglądzie, oraz określa miejsce i termin przeglądu.</p>

      <p>Oprócz ról opisanych powyżej mogą również występować bardziej szczegółowe role opisane w standardzie ISO/IEC 20246.</p>

      <h4>3.2.4 Typy przeglądów</h4>
      <p>Istnieje wiele typów przeglądów — od nieformalnych po formalne. <b>Wymagany stopień sformalizowania przeglądu zależy od takich czynników jak:</b></p>
      <ul>
        <li>przyjęty model cyklu wytwarzania oprogramowania</li>
        <li>dojrzałość procesu wytwarzania oprogramowania</li>
        <li>krytyczność i złożoność produktu pracy będącego przedmiotem przeglądu</li>
        <li>wymogi prawne</li>
        <li>konieczność prowadzenia ścieżki audytu</li>
      </ul>

      <p>Ten sam produkt pracy może być objęty różnymi typami przeglądów, na przykład najpierw przeglądem nieformalnym, a następnie przeglądem bardziej sformalizowanym.</p>

      <p><b>Wybór właściwego typu przeglądu ma zasadnicze znaczenie dla osiągnięcia wymaganych celów przeglądu.</b> Wyboru tego dokonuje się nie tylko na podstawie celów, ale również na podstawie czynników takich jak: potrzeby projektu, dostępne zasoby, typ produktu pracy i związane z nim ryzyka, dziedzina biznesowa oraz kultura organizacyjna firmy.</p>

      <p><b>Poniżej omówiono kilka często stosowanych typów przeglądów:</b></p>

      <p><b>• Przegląd nieformalny.</b> Przeglądy nieformalne nie przebiegają zgodnie ze zdefiniowanym procesem, a uzyskanych dzięki nim informacji nie trzeba formalnie dokumentować. Głównym celem jest wykrycie anomalii.</p>

      <p><b>• Przejrzenie.</b> Przejrzenie, które prowadzi autor, może służyć wielu celom, takim jak: dokonanie oceny jakości produktu pracy i zwiększenie zaufania do niego, edukowanie przeglądających, osiągnięcie konsensusu, wygenerowanie nowych pomysłów, zmotywowanie autorów do udoskonalania przyszłych produktów pracy i stworzenie im warunków do tego oraz wykrycie anomalii. Przed rozpoczęciem przejrzenia przeglądający mogą przeprowadzić przegląd indywidualny, ale nie jest to konieczne.</p>

      <p><b>• Przegląd techniczny.</b> Przegląd techniczny wykonują przeglądający, którzy dysponują odpowiednimi kwalifikacjami technicznymi, a nad przebiegiem procesu czuwa moderator. Celem przeglądu technicznego jest nie tylko osiągnięcie konsensusu i podjęcie decyzji w sprawie problemu technicznego, ale również wykrycie anomalii, dokonanie oceny jakości produktu pracy i zwiększenie zaufania do niego, wygenerowanie nowych pomysłów oraz zmotywowanie autorów do wprowadzania udoskonaleń i stworzenie im warunków do tego.</p>

      <p><b>• Inspekcja.</b> Inspekcja jest najbardziej formalnym typem przeglądu, w związku z czym odbywa się zgodnie z pełnym ogólnym procesem przeglądu. Głównym celem jest wykrycie jak największej liczby anomalii, a pozostałe cele to: dokonanie oceny jakości produktu pracy i zwiększenie zaufania do niego oraz zmotywowanie autorów do wprowadzania udoskonaleń i stworzenie im warunków do tego. Zbierane są metryki wykorzystywane następnie do udoskonalania cyklu wytwarzania oprogramowania (w tym procesu inspekcji). W ramach inspekcji autor nie może być liderem przeglądu ani protokolantem.</p>

      <h4>3.2.5 Czynniki powodzenia związane z przeglądami</h4>
      <p>Można wyróżnić kilka czynników, które decydują o pomyślnym przebiegu przeglądu, w tym:</p>

      <ul>
        <li><b>określenie jednoznacznych celów i mierzalnych kryteriów wyjścia</b> (przy czym celem nie powinna być w żadnym razie ocena uczestników)</li>
        <li><b>wybór odpowiedniego typu przeglądu</b>, który pozwoli osiągnąć zakładane cele oraz będzie odpowiedni do typu produktu pracy, uczestników przeglądu, potrzeb projektu i kontekstu</li>
        <li><b>przeprowadzanie przeglądów w odniesieniu do mniejszych partii materiału</b>, tak aby przeglądający nie tracili koncentracji podczas przeglądu indywidualnego i/lub spotkania związanego z przeglądem (jeśli jest organizowane)</li>
        <li><b>przekazywanie informacji zwrotnych z przeglądów interesariuszom i autorom</b>, tak aby mogli oni udoskonalać produkt i usprawniać swoje działania</li>
        <li><b>wyznaczenie uczestnikom wystarczającej ilości czasu na przygotowanie się do przeglądu</b></li>
        <li><b>uzyskanie wsparcia kierownictwa dla procesu przeglądu</b></li>
        <li><b>włączenie przeglądów w kulturę organizacyjną</b> w celu stworzenia atmosfery sprzyjającej poszerzaniu wiedzy i doskonaleniu procesów</li>
        <li><b>zapewnienie wszystkim uczestnikom należytego przeszkolenia</b> niezbędnego do prawidłowego wykonywania wyznaczonych im ról</li>
        <li><b>dbanie o sprawny przebieg spotkań</b></li>
      </ul>`,
    flashcards:[
      {q:"Podaj 2 korzyści z testowania statycznego.", a:"Wczesne wykrycie defektów (tańsze poprawki), możliwość oceny niewykonywalnych artefaktów, poprawa komunikacji, metryki jakości."},
      {q:"Najbardziej formalny typ przeglądu?", a:"Inspekcja – pełny proces, zbiera metryki."},
      {q:"Rola moderatora?", a:"Zapewnia sprawny, bezpieczny przebieg spotkania, zarządza czasem i mediacją."}
    ],
    quiz:[
      {q:"Które stwierdzenie najlepiej odróżnia testowanie statyczne od dynamicznego?", opt:["Statyczne uruchamia kod","Statyczne nie uruchamia kodu i może badać wymagania","Dynamiczne służy tylko do przeglądów","Statyczne wykrywa tylko błędy kompilacji"], a:1},
      {q:"Który typ przeglądu zbiera metryki i ma najsurowszy proces?", opt:["Nieformalny","Przejrzenie","Przegląd techniczny","Inspekcja"], a:3},
      {q:"Kto NIE jest rolą w przeglądach wg sylabusa?", opt:["Moderator","Product Owner","Protokolant","Przeglądający"], a:1},
      {q:"Które produkty pracy można badać metodą testowania statycznego?", opt:["Tylko kod źródłowy","Tylko dokumenty","Niemal wszystkie produkty pracy","Tylko plany testów"], a:2, exp:"Testowaniem statycznym można badać niemal wszystkie produkty pracy, w tym wymagania, kod, plany, przypadki testowe, dokumentację."},
      {q:"Co to jest analiza statyczna?", opt:["Przegląd kodu przez człowieka","Automatyczne badanie kodu bez uruchamiania","Testowanie wydajności","Testowanie bezpieczeństwa"], a:1, exp:"Analiza statyczna to automatyczne badanie kodu bez jego uruchamiania, często z wykorzystaniem narzędzi."},
      {q:"Które stwierdzenie o testowaniu statycznym jest prawdziwe?", opt:["Jest droższe od testowania dynamicznego","Wymaga tworzenia przypadków testowych","Może być elementem ciągłej integracji","Wykrywa tylko błędy składniowe"], a:2, exp:"Testowanie statyczne może być elementem mechanizmów ciągłej integracji i jest często mniej pracochłonne."},
      {q:"Który typ przeglądu jest najmniej formalny?", opt:["Inspekcja","Przegląd techniczny","Przejrzenie","Nieformalny"], a:3, exp:"Przegląd nieformalny jest najmniej formalnym typem przeglądu, często odbywa się ad-hoc."},
      {q:"Co to jest walkthrough?", opt:["Najbardziej formalny typ przeglądu","Przegląd prowadzony przez autora","Automatyczna analiza kodu","Testowanie dynamiczne"], a:1, exp:"Walkthrough to przegląd prowadzony przez autora produktu pracy, mniej formalny niż inspekcja."}
    ]
  },
  {
    id:"r4",
    title:"4. Analiza i projektowanie testów",
    read:`<h2>4. Analiza i projektowanie testów</h2>
      <h3>4.1 Ogólna charakterystyka technik testowania</h3>
      <p><b>Techniki testowania pomagają testerom w przeprowadzaniu analizy testów</b> (która odpowiada na pytanie „co należy przetestować") oraz w projektowaniu testów (które odpowiada na pytanie „jak należy testować"). Za pomocą tego typu technik można systematycznie opracować stosunkowo niewielki, ale wystarczający zbiór przypadków testowych.</p>

      <p>Ponadto techniki testowania ułatwiają definiowanie warunków testowych oraz identyfikowanie elementów pokrycia i danych testowych na etapie analizy i projektowania testów. Więcej informacji na temat technik testowania i odpowiadających im miar można znaleźć w standardzie <b>ISO/IEC/IEEE 29119-4</b> oraz w (Beizer 1990, Craig 2002, Copeland 2004, Koomen 2006, Jorgensen 2014, Ammann 2016, Forgács 2019).</p>

      <p>W niniejszym sylabusie techniki testowania podzielono na <b>czarnoskrzynkowe, białoskrzynkowe i oparte na doświadczeniu</b>.</p>

      <p><b>Czarnoskrzynkowe techniki testowania</b> (zwane także technikami opartymi na specyfikacji) bazują na analizie wyspecyfikowanego zachowania przedmiotu testów bez odwoływania się do jego struktury wewnętrznej. Oznacza to, że przypadki testowe są niezależne od sposobu implementacji oprogramowania, a co za tym idzie mogą być nadal stosowane w przypadku zmiany implementacji, która nie pociąga za sobą zmiany wymaganego zachowania.</p>

      <p><b>Podstawą białoskrzynkowych technik testowania</b> (zwanych także technikami opartymi na strukturze) jest analiza struktury wewnętrznej przedmiotu testów i wykonywanego w nim przetwarzania. Przypadki testowe są uzależnione od sposobu, w jaki zaprojektowano dane oprogramowanie, w związku z czym można je tworzyć dopiero po zaprojektowaniu lub zaimplementowaniu przedmiotu testów.</p>

      <p><b>Techniki testowania oparte na doświadczeniu</b> pozwalają wykorzystać wiedzę i doświadczenie testerów do projektowania i implementowania przypadków testowych. Skuteczność tego rodzaju technik zależy w dużej mierze od umiejętności testera. Techniki oparte na doświadczeniu pozwalają wykrywać defekty, które łatwo jest przeoczyć w przypadku stosowania technik czarnoskrzynkowych i białoskrzynkowych, a tym samym znakomicie uzupełniają powyższe techniki.</p>

      <h3>4.2 Czarnoskrzynkowe techniki testowania</h3>
      <p>W kolejnych sekcjach omówione zostały następujące powszechnie stosowane czarnoskrzynkowe techniki testowania:</p>
      <ul>
        <li>podział na klasy równoważności</li>
        <li>analiza wartości brzegowych</li>
        <li>testowanie w oparciu o tablicę decyzyjną</li>
        <li>testowanie przejść pomiędzy stanami</li>
      </ul>

      <h4>4.2.1 Podział na klasy równoważności</h4>
      <p><b>Technika podziału na klasy równoważności polega na dzieleniu danych na klasy (zwane klasami równoważności) zgodnie z założeniem, że każda klasa będzie zawierała elementy, które mają być przetwarzane przez przedmiot testów w ten sam sposób.</b> U podstaw tej techniki leży teoria, zgodnie z którą jeśli przypadek testowy służący do testowania jednej wartości z klasy równoważności wykryje defekt, to defekt ten powinien również zostać wykryty przez przypadki testowe służące do testowania każdej innej wartości należącej do tej samej klasy. Oznacza to, że wystarczające jest utworzenie jednego testu w odniesieniu do każdej z klas.</p>

      <p><b>Klasy równoważności można wyznaczać w odniesieniu do wszelkich elementów danych, które są związane z przedmiotem testów, takich jak:</b></p>
      <ul>
        <li>dane wejściowe</li>
        <li>dane wyjściowe</li>
        <li>elementy konfiguracji</li>
        <li>wartości wewnętrzne</li>
        <li>wartości zależne od czasu</li>
        <li>parametry interfejsu</li>
      </ul>

      <p>Klasy mogą być ciągłe lub dyskretne, uporządkowane lub nieuporządkowane oraz skończone lub nieskończone, nie mogą natomiast nakładać się na siebie ani być pustymi zbiorami.</p>

      <p>W przypadku prostych elementów testowych podział na klasy równoważności nie sprawia zwykle trudności, ale w praktyce zrozumienie tego, jak dany obiekt testowy będzie traktować poszczególne wartości, bywa skomplikowane. Z tego powodu przy dokonywaniu podziału należy zachować ostrożność.</p>

      <p><b>Klasa równoważności zawierająca poprawne wartości jest nazywana poprawną klasą równoważności, a klasa zawierająca wartości niepoprawne — niepoprawną klasą równoważności.</b> Definicje wartości poprawnych i niepoprawnych mogą przy tym różnić się w zależności od zespołu lub organizacji. Za wartości poprawne mogą być na przykład uważane takie, które powinny być przetwarzane przez przedmiot testów, lub takie, w przypadku których sposób przetwarzania określa specyfikacja. Z kolei za wartości niepoprawne mogą być uznawane wartości, które przedmiot testów powinien zignorować lub odrzucić, bądź wartości, w odniesieniu do których w specyfikacji przedmiotu testów nie zdefiniowano sposobu przetwarzania.</p>

      <p><b>W przypadku podziału na klasy równoważności elementami pokrycia są klasy równoważności.</b> Warunkiem uzyskania stuprocentowego pokrycia przy korzystaniu z tej techniki jest sprawdzenie za pomocą przypadków testowych wszystkich zidentyfikowanych klas (w tym klas niepoprawnych) poprzez pokrycie każdej klasy co najmniej raz. Pokrycie mierzy się jako iloraz liczby klas sprawdzonych za pomocą co najmniej jednego przypadku testowego przez łączną liczbę zidentyfikowanych klas, a uzyskaną wartość wyraża się w procentach.</p>

      <p>W wielu elementach testowych występuje po kilka zbiorów klas (przykładem mogą być elementy testowe mające więcej niż jeden parametr wejściowy), co oznacza, że przypadek testowy będzie pokrywać klasy należące do kilku różnych zbiorów. <b>Najprostszym kryterium pokrycia w przypadku występowania wielu zbiorów klas jest pokrycie typu „każdy wybór" (ang. each choice)</b> (Ammann 2016). Wymaga ono, aby przypadki testowe sprawdzały każdą klasę z każdego zbioru klas co najmniej raz. Pokrycie to nie uwzględnia kombinacji klas.</p>

      <h4>4.2.2 Analiza wartości brzegowych</h4>
      <p><b>Technika analizy wartości brzegowych polega na sprawdzaniu wartości brzegowych klas równoważności</b>, w związku z czym może być stosowana tylko w odniesieniu do klas uporządkowanych. Wartościami brzegowymi klasy równoważności są jej wartość minimalna i maksymalna. W przypadku analizy wartości brzegowych zakłada się, że jeśli dwa elementy należą do tej samej klasy, to wszystkie elementy leżące pomiędzy nimi również muszą należeć do tej klasy.</p>

      <p>Opisywana technika skupia się na wartościach brzegowych klas ze względu na większe prawdopodobieństwo popełnienia przez programistów pomyłek właśnie w przypadku takich wartości. <b>Typowe defekty wykrywane metodą analizy wartości brzegowych znajdują się tam, gdzie zaimplementowane wartości brzegowe zostały omyłkowo umieszczone powyżej lub poniżej zamierzonego położenia lub całkowicie pominięte.</b></p>

      <p>W niniejszym sylabusie omówiono dwa warianty analizy wartości brzegowych: <b>analizę dwupunktową i analizę trójpunktową</b>. Warianty te różnią się liczbą elementów pokrycia przypadających na każdą z wartości brzegowych, które muszą zostać sprawdzone w celu uzyskania stuprocentowego pokrycia.</p>

      <p><b>W przypadku dwupunktowej analizy wartości brzegowych</b> (Craig 2002, Myers 2011) na każdą wartość brzegową przypadają dwa elementy pokrycia: sama wartość brzegowa oraz najbliższa jej wartość należąca do sąsiedniej klasy równoważności. Warunkiem uzyskania stuprocentowego pokrycia przy korzystaniu z dwupunktowej analizy wartości brzegowych jest sprawdzenie za pomocą przypadków testowych wszystkich elementów pokrycia, czyli wszystkich zidentyfikowanych wartości brzegowych. Pokrycie mierzy się jako iloraz liczby sprawdzonych wartości brzegowych przez łączną liczbę zidentyfikowanych wartości brzegowych, a uzyskaną wartość wyraża się w procentach.</p>

      <p><b>W przypadku trójpunktowej analizy wartości brzegowych</b> (Koomen 2006, O'Regan 2019) na każdą wartość brzegową przypadają trzy elementy pokrycia: sama wartość brzegowa oraz obie wartości sąsiednie. W związku z tym w ramach trójpunktowej analizy wartości brzegowych niektóre elementy pokrycia mogą nie być wartościami brzegowymi. Warunkiem uzyskania stuprocentowego pokrycia przy korzystaniu z trójpunktowej analizy wartości brzegowych jest sprawdzenie za pomocą przypadków testowych wszystkich elementów pokrycia, czyli zidentyfikowanych wartości brzegowych i ich wartości sąsiednich. Pokrycie mierzy się jako iloraz liczby sprawdzonych wartości brzegowych i wartości sąsiednich przez łączną liczbę zidentyfikowanych wartości brzegowych i ich wartości sąsiednich, a uzyskaną wartość wyraża się w procentach.</p>

      <p><b>Trójpunktowa analiza wartości brzegowych jest bardziej rygorystyczna niż analiza dwupunktowa</b>, ponieważ pozwala wykryć defekty, które można przeoczyć w przypadku tej ostatniej. Na przykład jeśli decyzja „if (x ≤ 10) …" zostanie błędnie zaimplementowana jako „if (x = 10) …", dane testowe uzyskane w ramach dwupunktowej analizy wartości brzegowych (x = 10, x = 11) mogą nie pozwolić na wykrycie defektu. Jeśli natomiast zostanie zastosowana wartość x = 9 uzyskana w wyniku analizy trójpunktowej, defekt prawdopodobnie zostanie wykryty.</p>

      <h4>4.2.3 Testowanie w oparciu o tablicę decyzyjną</h4>
      <p><b>Tablice decyzyjne służą do testowania implementacji wymagań systemowych, które określają, w jaki sposób różne kombinacje warunków powodują uzyskanie różnych wyników.</b> Za pomocą tablic decyzyjnych można sprawnie odzwierciedlać złożone mechanizmy logiczne, takie jak reguły biznesowe.</p>

      <p>Przy opracowywaniu tablic decyzyjnych określa się warunki i wynikające z nich akcje systemu, które tworzą wiersze tablicy. Każda kolumna odpowiada regule decyzyjnej, która określa unikatową kombinację warunków wraz z powiązanymi akcjami. <b>W ograniczonych tablicach decyzyjnych wszystkie wartości warunków i akcji</b> (z wyjątkiem warunków nieistotnych lub niemożliwych do spełnienia; patrz poniżej) <b>przedstawia się jako wartości logiczne (prawda/fałsz).</b> Alternatywą dla powyższego wariantu są uogólnione tablice decyzyjne, w których niektóre lub wszystkie warunki i akcje mogą również przyjmować wiele wartości (takich jak przedziały liczb, klasy równoważności czy wartości dyskretne).</p>

      <p><b>Notacja warunków jest następująca:</b></p>
      <ul>
        <li>„P" (prawda) oznacza, że warunek został spełniony</li>
        <li>„F" (fałsz) oznacza, że warunek nie został spełniony</li>
        <li>„—" oznacza, że wartość warunku nie ma znaczenia dla wyniku akcji</li>
        <li>„nd" („nie dotyczy") oznacza, że warunek nie występuje w przypadku danej reguły</li>
      </ul>

      <p>W przypadku akcji „X" oznacza, że akcja powinna zostać wykonana, a puste pole — że nie powinna zostać wykonana. Mogą być również stosowane inne notacje.</p>

      <p><b>Pełna tablica decyzyjna zawiera tyle kolumn, ile jest niezbędne do pokrycia wszystkich kombinacji warunków.</b> Tablicę można uprościć poprzez usunięcie kolumn zawierających kombinacje warunków, które są niemożliwe do spełnienia. Ponadto można ją zminimalizować poprzez scalenie kolumn, w których część warunków nie ma wpływu na wynik, w jedną kolumnę. Należy jednak zaznaczyć, że algorytmy minimalizowania tablic decyzyjnych nie są przedmiotem niniejszego sylabusa.</p>

      <p><b>W przypadku testowania w oparciu o tablicę decyzyjną elementami pokrycia są kolumny zawierające możliwe do spełnienia kombinacje warunków.</b> Warunkiem uzyskania stuprocentowego pokrycia przy korzystaniu z tej techniki jest sprawdzenie za pomocą przypadków testowych wszystkich powyższych kolumn. Pokrycie mierzy się jako iloraz liczby sprawdzonych kolumn przez łączną liczbę kolumn zawierających możliwe do spełnienia warunki, a uzyskana wartość jest wyrażona w procentach.</p>

      <p><b>Zaletą testowania w oparciu o tablicę decyzyjną jest systematyczne podejście umożliwiające zidentyfikowanie wszystkich kombinacji warunków, które w innym przypadku mogłyby zostać przeoczone.</b> Ponadto metoda ta pomaga znaleźć ewentualne luki lub sprzeczności w wymaganiach. Jeśli występuje duża liczba warunków, sprawdzenie wszystkich reguł decyzyjnych może być czasochłonne, ponieważ liczba reguł rośnie wykładniczo wraz z liczbą warunków. W takim przypadku w celu zmniejszenia liczby reguł wymagających sprawdzenia można zminimalizować tablicę decyzyjną lub zastosować podejście oparte na ryzyku.</p>

      <h4>4.2.4 Testowanie przejść pomiędzy stanami</h4>
      <p><b>Diagram stanów umożliwia modelowanie zachowania systemu poprzez zobrazowanie jego możliwych stanów i poprawnych przejść między nimi.</b> Przejście jest inicjowane przez zdarzenie, które może być dodatkowo kwalifikowane przez warunek dozoru. Przyjmuje się, że przejścia są natychmiastowe i mogą niekiedy powodować wykonanie przez oprogramowanie określonej akcji. <b>Typowa notacja stosowana do oznaczania przejść ma postać „zdarzenie [warunek dozoru] / akcja"</b>, przy czym warunki dozoru i akcje można pominąć, jeśli nie istnieją lub są nieistotne z punktu widzenia testera.</p>

      <p><b>Tablica stanów jest modelem równoważnym diagramowi stanów.</b> Jej wiersze odpowiadają stanom, a kolumny — zdarzeniom (wraz z ewentualnymi warunkami dozoru). Wpisy w tabeli (komórki) odpowiadają przejściom i zawierają informacje o stanie docelowym oraz o akcjach wynikających z przejść (jeśli zostały zdefiniowane). W przeciwieństwie od diagramu stanów tablica stanów wyraźnie wskazuje niepoprawne przejścia, którym odpowiadają puste komórki.</p>

      <p><b>Przypadek testowy oparty na diagramie stanów lub tablicy stanów jest zwykle wyrażany w postaci sekwencji zdarzeń, która powoduje wykonanie sekwencji zmian stanu (oraz akcji, jeśli są wymagane).</b> Jeden przypadek testowy może pokrywać (i zwykle pokrywa) kilka przejść pomiędzy stanami.</p>

      <p>Istnieje wiele kryteriów pokrycia, które można wykorzystać w testowaniu przejść pomiędzy stanami. W niniejszym sylabusie omówiono trzy z nich.</p>

      <p><b>W przypadku pokrycia wszystkich stanów elementami pokrycia są właśnie stany.</b> Warunkiem uzyskania stuprocentowego pokrycia wszystkich stanów jest przejście za pomocą przypadków testowych przez wszystkie istniejące stany. Pokrycie mierzy się jako iloraz liczby wykonanych stanów przez łączną liczbę stanów, a uzyskana wartość jest wyrażona w procentach.</p>

      <p><b>W przypadku pokrycia poprawnych przejść (zwanego także pokryciem 0-przełączeń) elementami pokrycia są pojedyncze poprawne przejścia.</b> Warunkiem uzyskania stuprocentowego pokrycia poprawnych przejść jest wykonanie za pomocą przypadków testowych wszystkich poprawnych przejść. Pokrycie mierzy się jako iloraz liczby wykonanych poprawnych przejść przez łączną liczbę poprawnych przejść, a uzyskana wartość jest wyrażona w procentach.</p>

      <p><b>W przypadku pokrycia wszystkich przejść elementami pokrycia są wszystkie przejścia wskazane w tablicy stanów.</b> Warunkiem uzyskania stuprocentowego pokrycia wszystkich przejść jest wykonanie za pomocą przypadków testowych wszystkich poprawnych przejść oraz podjęcie próby wykonania niepoprawnych przejść. Testowanie tylko jednego niepoprawnego przejścia w jednym przypadku testowym pozwala uniknąć maskowania defektów, czyli sytuacji, w której jeden defekt uniemożliwia wykrycie innego defektu. Pokrycie mierzy się jako iloraz liczby poprawnych i niepoprawnych przejść, które zostały wykonane lub w przypadku których podjęto próbę wykonania za pomocą przypadków testowych przez łączną liczbę poprawnych i niepoprawnych przejść, a uzyskana wartość jest wyrażona w procentach.</p>

      <p><b>Pokrycie wszystkich stanów jest słabszym kryterium niż pokrycie poprawnych przejść</b>, ponieważ można je zwykle osiągnąć bez wykonania wszystkich przejść. <b>Pokrycie poprawnych przejść jest najczęściej stosowanym kryterium pokrycia.</b> Uzyskanie pełnego pokrycia poprawnych przejść gwarantuje pełne pokrycie wszystkich stanów, a uzyskanie pełnego pokrycia wszystkich przejść gwarantuje zarówno pełne pokrycie wszystkich stanów, jak i pełne pokrycie poprawnych przejść, w związku z czym powinno być wymogiem minimalnym w przypadku oprogramowania o newralgicznym znaczeniu dla działalności przedsiębiorstwa, a także oprogramowania krytycznego ze względów bezpieczeństwa.</p>

      <h3>4.3 Białoskrzynkowe techniki testowania</h3>
      <p>Z uwagi na ich popularność i prostotę w niniejszym podrozdziale skupiono się na dwóch białoskrzynkowych technikach testowania związanych z kodem. Są to:</p>
      <ul>
        <li>testowanie instrukcji</li>
        <li>testowanie gałęzi</li>
      </ul>

      <p>Istnieją również bardziej rygorystyczne techniki, których używa się w systemach krytycznych ze względów bezpieczeństwa, w systemach o newralgicznym znaczeniu dla działalności przedsiębiorstwa oraz w środowiskach wymagających wysokiego poziomu integralności w celu uzyskania pełniejszego pokrycia kodu. Istnieją także białoskrzynkowe techniki testowania używane na wyższych poziomach testów (np. w ramach testowania API) lub korzystające z pokrycia niezwiązanego z kodem (np. pokrycia neuronów w testowaniu sieci neuronowych). Nie są one jednak przedmiotem niniejszego sylabusa.</p>

      <h4>4.3.1 Testowanie instrukcji i pokrycie instrukcji kodu</h4>
      <p><b>W przypadku testowania instrukcji elementami pokrycia są instrukcje wykonywalne.</b> Technika ta służy do projektowania przypadków testowych, które sprawdzają instrukcje w kodzie do momentu osiągnięcia akceptowalnego poziomu pokrycia. Pokrycie mierzy się jako iloraz liczby instrukcji sprawdzonych za pomocą przypadków testowych przez łączną liczbę instrukcji wykonywalnych w kodzie, a uzyskana wartość jest wyrażona w procentach.</p>

      <p><b>Uzyskanie stuprocentowego pokrycia instrukcji kodu gwarantuje, że każda instrukcja wykonywalna została sprawdzona co najmniej raz.</b> Oznacza to w szczególności wykonanie każdej instrukcji zawierającej defekt, co może spowodować awarię potwierdzającą istnienie defektu. Należy jednak zaznaczyć, że sprawdzenie instrukcji za pomocą przypadku testowego nie zawsze powoduje wykrycie defektu — istnieje na przykład ryzyko niewykrycia defektów, które są zależne od danych (takich jak dzielenie przez zero, które powoduje awarię tylko w przypadku nadania mianownikowi wartości zerowej).</p>

      <p>Ponadto uzyskanie stuprocentowego pokrycia instrukcji kodu nie gwarantuje, że została przetestowana cała logika decyzyjna, ponieważ testy mogą na przykład nie sprawdzać wszystkich gałęzi kodu (patrz sekcja 4.3.2).</p>

      <h4>4.3.2 Testowanie gałęzi i pokrycie gałęzi</h4>
      <p><b>Gałąź reprezentuje przepływ sterowania między dwoma wierzchołkami w diagramie przepływu sterowania przedstawiającym możliwe sekwencje wykonywania instrukcji kodu źródłowego w przedmiocie testów.</b> Każdy przepływ sterowania może odbywać się albo bezwarunkowo (kod liniowy), albo warunkowo (wynik decyzji).</p>

      <p><b>W przypadku testowania gałęzi elementami pokrycia są gałęzie, a celem jest zaprojektowanie przypadków testowych sprawdzających gałęzie kodu do momentu osiągnięcia akceptowalnego poziomu pokrycia.</b> Pokrycie mierzy się jako iloraz liczby gałęzi sprawdzonych za pomocą co najmniej jednego przypadku testowego przez łączną liczbę gałęzi, a uzyskana wartość jest wyrażona w procentach.</p>

      <p><b>Uzyskanie stuprocentowego pokrycia gałęzi oznacza, że wszystkie gałęzie kodu — zarówno bezwarunkowe, jak i warunkowe — zostały sprawdzone za pomocą przypadków testowych.</b> Gałęzie warunkowe zwykle odpowiadają wynikowi „prawda" lub „fałsz" decyzji „IF … THEN", wynikowi instrukcji SWITCH/CASE bądź decyzji o wyjściu z pętli lub dalszym wykonywaniu pętli. Należy jednak zaznaczyć, że sprawdzenie gałęzi za pomocą przypadku testowego nie zawsze powoduje wykrycie defektu — istnieje na przykład ryzyko niewykrycia defektów, które wymagają wykonania konkretnej ścieżki w kodzie.</p>

      <p><b>Pokrycie gałęzi subsumuje pokrycie instrukcji kodu, co oznacza, że każdy zbiór przypadków testowych osiągający stuprocentowe pokrycie gałęzi osiąga również stuprocentowe pokrycie instrukcji kodu (ale nie odwrotnie).</b></p>

      <h4>4.3.3 Korzyści wynikające z testowania białoskrzynkowego</h4>
      <p><b>Zasadniczą zaletą wszystkich technik białoskrzynkowych jest fakt, że podczas testowania uwzględniana jest cała implementacja oprogramowania, co ułatwia wykrywanie defektów nawet w przypadku, gdy specyfikacja oprogramowania jest niejednoznaczna, nieaktualna lub niekompletna.</b> Wadą jest z kolei fakt, że w przypadku niezaimplementowania w oprogramowaniu jednego lub kilku wymagań testowanie białoskrzynkowe może nie wykryć spowodowanych tym defektów w postaci pominięć (Watson 1996).</p>

      <p><b>Techniki białoskrzynkowe mogą być stosowane w testowaniu statycznym</b> (np. podczas próbnych przebiegów kodu - ang. dry runs). Sprawdzają się również w przeglądach kodu, który nie jest jeszcze gotowy do uruchomienia (Hetzel 1988), a także pseudokodu oraz mechanizmów logicznych, które można odwzorować w postaci diagramu przepływu sterowania.</p>

      <p><b>Wykonanie jedynie testowania czarnoskrzynkowego nie pozwala zmierzyć faktycznego pokrycia kodu</b>, natomiast miary pokrycia stosowane w technikach białoskrzynkowych zapewniają obiektywny pomiar pokrycia i dostarczają niezbędnych informacji umożliwiających wygenerowanie dodatkowych testów w celu jego zwiększenia, co ostatecznie przekłada się na wzrost zaufania do kodu.</p>

      <h3>4.4 Techniki testowania oparte na doświadczeniu</h3>
      <p>W kolejnych sekcjach omówiono następujące powszechnie stosowane techniki testowania oparte na doświadczeniu:</p>
      <ul>
        <li>zgadywanie błędów</li>
        <li>testowanie eksploracyjne</li>
        <li>testowanie w oparciu o listę kontrolną</li>
      </ul>

      <h4>4.4.1 Zgadywanie błędów</h4>
      <p><b>Zgadywanie błędów to technika pozwalająca przewidywać wystąpienie błędów, defektów i awarii na podstawie wiedzy testera dotyczącej między innymi:</b></p>
      <ul>
        <li>dotychczasowego działania aplikacji</li>
        <li>typowych błędów popełnianych przez programistów i typów wynikających z nich defektów</li>
        <li>rodzajów awarii, które wystąpiły w innych podobnych aplikacjach</li>
      </ul>

      <p><b>Zasadniczo błędy, defekty i awarie mogą być związane z:</b></p>
      <ul>
        <li><b>danymi wejściowymi</b> (np. nieprzyjęcie poprawnych danych wejściowych bądź błędne lub brakujące parametry)</li>
        <li><b>danymi wyjściowymi</b> (np. nieprawidłowy format lub nieprawidłowy rezultat)</li>
        <li><b>logiką</b> (np. brakujące przypadki lub nieprawidłowy operator)</li>
        <li><b>obliczeniami</b> (np. niepoprawny argument operacji lub błędne obliczenie)</li>
        <li><b>interfejsami</b> (np. niezgodność parametrów lub typów)</li>
        <li><b>danymi</b> (np. niepoprawne zainicjowanie lub niewłaściwy typ danych)</li>
      </ul>

      <p><b>Przykładem metodycznego podejścia do zgadywania błędów są ataki usterek.</b> Technika ta wymaga od testera stworzenia lub uzyskania listy potencjalnych błędów, defektów i awarii, a następnie zaprojektowania testów pozwalających zidentyfikować defekty związane z błędami z listy, uwidocznić defekty z listy bądź spowodować awarie z listy. Listy takie można opracowywać na podstawie własnego doświadczenia, danych dotyczących defektów i awarii oraz powszechnej wiedzy na temat przyczyn awarii oprogramowania.</p>

      <p>Więcej informacji na temat zgadywania błędów i ataków usterek zawierają pozycje (Whittaker 2002, Whittaker 2003, Andrews 2006).</p>

      <h4>4.4.2 Testowanie eksploracyjne</h4>
      <p><b>Testowanie eksploracyjne polega na równoczesnym projektowaniu, wykonywaniu i dokonywaniu oceny testów w czasie, gdy tester zapoznaje się z przedmiotem testów.</b> Proces ten dostarcza wiedzy na temat przedmiotu testów, a także pozwala tworzyć ukierunkowane testy umożliwiające jego dokładniejsze zbadanie oraz testy dotyczące obszarów dotychczas nieprzetestowanych.</p>

      <p><b>Testowanie eksploracyjne jest czasami przeprowadzane metodą tzw. testowania w sesjach, która pozwala uporządkować cały proces.</b> W ramach testowania w sesjach testowanie eksploracyjne odbywa się w ściśle określonym przedziale czasu, a tester prowadzi testy zgodnie z kartą opisu testu (zawierającą cele testów). Po zakończeniu sesji testowej zwykle odbywa się spotkanie podsumowujące, którego elementem jest dyskusja między testerem a interesariuszami zainteresowanymi wynikami sesji testowej.</p>

      <p>W ramach tego podejścia cele testów można potraktować jako warunki testowe wysokiego poziomu. W trakcie sesji testowej identyfikuje się i sprawdza elementy pokrycia. Do dokumentowania wykonywanych kroków testowych i uzyskiwanych informacji służą arkusze sesji testowych.</p>

      <p><b>Testowanie eksploracyjne jest przydatne w przypadku niepełnych lub niewłaściwie sporządzonych specyfikacji bądź w przypadku testowania pod presją czasu.</b> Ponadto może być uzupełnieniem innych, bardziej formalnych technik testowania. Wśród czynników zwiększających skuteczność testowania eksploracyjnego można wymienić doświadczenie i wiedzę merytoryczną testera oraz wysoki poziom niezbędnych umiejętności, takich jak umiejętność analizy, ciekawość i kreatywność (patrz sekcja 1.5.1).</p>

      <p>W ramach testowania eksploracyjnego można korzystać także z innych technik (np. techniki podziału na klasy równoważności). Więcej informacji na temat testowania eksploracyjnego można znaleźć w (Kaner 1999, Whittaker 2009, Hendrickson 2013).</p>

      <h4>4.4.3 Testowanie w oparciu o listę kontrolną</h4>
      <p><b>W ramach testowania w oparciu o listę kontrolną testerzy projektują, implementują i wykonują testy tak, aby pokryć warunki testowe wymienione na liście kontrolnej.</b> Listy kontrolne można opracowywać na podstawie własnego doświadczenia, znajomości oczekiwań użytkowników lub wiedzy na temat przyczyn i objawów awarii oprogramowania. Należy jednak pamiętać, że nie powinny one zawierać elementów, które można sprawdzić automatycznie, które lepiej jest wykorzystać jako kryteria wejścia lub kryterium wyjścia lub które są zbyt ogólne (Brykczynski 1999).</p>

      <p><b>Elementy listy kontrolnej są często formułowane jako pytania, przy czym powinno być możliwe bezpośrednie sprawdzenie każdego z nich z osobna.</b> Elementy te mogą dotyczyć wymagań, właściwości interfejsu graficznego, charakterystyk jakościowych lub innego rodzaju warunków testowych. Listy kontrolne można tworzyć na potrzeby różnych typów testów, w tym na potrzeby testowania funkcjonalnego i niefunkcjonalnego, czego przykładem jest 10 heurystyk w zakresie testowania użyteczności (Nielsen 1994).</p>

      <p><b>Z czasem niektóre pozycje listy kontrolnej mogą stopniowo tracić skuteczność, ponieważ programiści uczą się unikać popełniania tych samych pomyłek.</b> Ponadto może być konieczne dodanie nowych pozycji odzwierciedlających nowo wykryte defekty o dużej krytyczności. Z powyższych powodów listy kontrolne powinny być regularnie aktualizowane na podstawie analizy defektów, jednak należy zachować ostrożność, aby nie stały się one zbyt obszerne (Gawande 2009).</p>

      <p>W sytuacji, w której brakuje szczegółowych przypadków testowych, testowanie w oparciu o listę kontrolną zapewnia niezbędne wytyczne i pozwala uzyskać pewien stopień spójności testowania. Jeśli listy kontrolne mają charakter wysokopoziomowy, podczas faktycznego testowania może występować pewna zmienność przekładająca się na większe pokrycie, ale kosztem mniejszej powtarzalności.</p>

      <h3>4.5 Podejścia do testowania oparte na współpracy</h3>
      <p>Każda z wyżej wymienionych technik (patrz podrozdziały 4.2, 4.3 i 4.4) ma określony cel związany z wykrywaniem defektów, natomiast <b>podejścia oparte na współpracy koncentrują się również na unikaniu defektów poprzez zapewnienie współpracy i wymiany informacji.</b></p>

      <h4>4.5.1 Wspólne pisanie historyjek użytkownika</h4>
      <p><b>Historyjka użytkownika reprezentuje cechę systemu wartościową dla użytkownika bądź nabywcy systemu lub oprogramowania.</b> W historyjkach użytkownika wyróżnia się trzy kluczowe aspekty (Jeffries 2000) nazywane łącznie „3 C" od pierwszych liter ich angielskich nazw. Są to:</p>
      <ul>
        <li><b>karta (ang. card)</b>, czyli nośnik zawierający opis historyjki użytkownika (np. karta katalogowa bądź wpis w kartotece elektronicznej)</li>
        <li><b>rozmowa (ang. conversation)</b>, która wyjaśnia, w jaki sposób będzie używane oprogramowanie (w postaci udokumentowanej lub słownej)</li>
        <li><b>potwierdzenie (ang. confirmation)</b>, czyli kryteria akceptacji (patrz sekcja 4.5.2)</li>
      </ul>

      <p><b>Najczęściej stosowany format historyjki użytkownika ma postać zdania „Jako [rola] chcę [zakładany cel do osiągnięcia], abym mógł/mogła [wartość biznesowa uzyskiwana w kontekście danej roli]", po którym następują kryteria akceptacji.</b></p>

      <p>Podczas wspólnego tworzenia historyjki użytkownika można korzystać z technik takich jak burza mózgów czy tworzenie map myśli. Dzięki współpracy zespół może wypracować wspólną wizję tego, co należy dostarczyć, z uwzględnieniem trzech punktów widzenia: biznesowego, programistycznego i testowego.</p>

      <p><b>Dobre historyjki użytkownika powinny być niezależne, negocjowalne, wartościowe, możliwe do oszacowania, zwięzłe i testowalne (ang. Independent, Negotiable, Valuable, Estimable, Small, Testable — INVEST).</b> Jeśli interesariusz nie wie, jak należy przetestować daną historyjkę użytkownika, może to wskazywać, że nie jest ona wystarczająco jednoznaczna lub nie odzwierciedla kwestii istotnych dla tego interesariusza. Nie można też jednak wykluczyć, że interesariusz po prostu potrzebuje pomocy w testowaniu (Wake 2003).</p>

      <h4>4.5.2 Kryteria akceptacji</h4>
      <p><b>Kryteria akceptacji związane z historyjką użytkownika to warunki, jakie muszą zostać spełnione, aby implementacja tej historyjki została zaakceptowana przez interesariuszy.</b> Z tej perspektywy kryteria akceptacji można potraktować jako warunki testowe, których spełnienie powinno zostać sprawdzone w trakcie testów. Kryteria akceptacji powstają zwykle w wyniku rozmowy (patrz sekcja 4.5.1).</p>

      <p><b>Celem kryteriów akceptacji jest:</b></p>
      <ul>
        <li>określenie zakresu historyjki użytkownika</li>
        <li>osiągnięcie konsensusu wśród interesariuszy</li>
        <li>opisanie pozytywnych i negatywnych scenariuszy</li>
        <li>stworzenie podstawy do testowania akceptacyjnego historyjki użytkownika (patrz sekcja 4.5.3)</li>
        <li>umożliwienie dokładnego planowania i szacowania</li>
      </ul>

      <p><b>Kryteria akceptacji związane z historyjką użytkownika można pisać na kilka sposobów. Dwa najpopularniejsze formaty to:</b></p>
      <ul>
        <li><b>format ukierunkowany na scenariusze</b> (np. format Given/When/Then stosowany w wytwarzaniu sterowanym zachowaniem; patrz sekcja 2.1.3)</li>
        <li><b>format ukierunkowany na reguły</b> (np. lista weryfikacyjna w punktach lub przypisanie danych wejściowych do danych wyjściowych w formie tabelarycznej)</li>
      </ul>

      <p>Większość kryteriów akceptacji można udokumentować w jednym z dwóch powyższych formatów, ale zespół może również skorzystać z innego, niestandardowego formatu pod warunkiem, że kryteria będą należycie zdefiniowane i jednoznaczne.</p>

      <h4>4.5.3 Wytwarzanie sterowane testami akceptacyjnymi (ATDD)</h4>
      <p><b>Wytwarzanie sterowane testami akceptacyjnymi to podejście typu „najpierw test" (patrz sekcja 2.1.3), zgodnie z którym przypadki testowe tworzy się przed zaimplementowaniem historyjki użytkownika.</b> Tworzeniem przypadków testowych zajmują się członkowie zespołu mający różne punkty widzenia, na przykład klienci, programiści i testerzy (Adzic 2009). Uzyskane w ten sposób przypadki testowe mogą być następnie wykonywane manualnie lub automatycznie.</p>

      <p><b>Pierwszym krokiem jest przeprowadzenie warsztatów tworzenia specyfikacji, podczas których członkowie zespołu analizują, omawiają i piszą historyjkę użytkownika oraz związane z nią kryteria akceptacji</b> (o ile nie zostały jeszcze zdefiniowane). W ramach tego procesu korygowane są wszelkie braki, niejednoznaczności lub defekty występujące w historyjce użytkownika. Kolejnym krokiem jest stworzenie przypadków testowych, przy czym czynność ta może być wykonywana przez cały zespół lub indywidualnie przez testera.</p>

      <p><b>Przypadki testowe są tworzone w oparciu o kryteria akceptacji i mogą być traktowane jako przykłady sposobu działania oprogramowania.</b> Dzięki temu zespół może poprawnie zaimplementować historyjkę użytkownika.</p>

      <p>Z uwagi na to, że przykłady i testy są takie same, pojęcia te bywają często używane zamiennie. Podczas projektowania testów można stosować techniki testowania opisane w podrozdziałach 4.2, 4.3 i 4.4.</p>

      <p><b>Pierwsze przypadki testowe są z reguły przypadkami pozytywnymi, co oznacza, że mają na celu potwierdzenie prawidłowego zachowania — bez wyjątków lub warunków błędów — i odzwierciedlają sekwencję czynności wykonywaną w sytuacji, w której wszystko działa zgodnie z oczekiwaniami.</b> Po wykonaniu pozytywnych przypadków testowych zespół powinien przystąpić do testowania negatywnego, a na koniec powinien również zadbać o pokrycie niefunkcjonalnych charakterystyk jakościowych (takich jak wydajność czy użyteczność).</p>

      <p><b>Przypadki testowe powinny być wyrażone w sposób zrozumiały dla interesariuszy.</b> Zazwyczaj zawierają one zdania w języku naturalnym określające niezbędne warunki wstępne (jeśli mają zastosowanie), dane wejściowe oraz warunki wyjściowe.</p>

      <p><b>Przypadki testowe muszą pokrywać wszystkie charakterystyki historyjki użytkownika, ale nie powinny wykraczać poza jej zakres</b>, natomiast kryteria akceptacji mogą opisywać szczegółowo niektóre kwestie opisane w historyjce. Ponadto należy unikać sytuacji, w których dwa przypadki testowe opisują tę samą charakterystykę historyjki użytkownika.</p>

      <p><b>Jeśli przypadki testowe zostaną zarejestrowane w formacie obsługiwanym przez strukturę do testów automatycznych, programiści mogą zautomatyzować ich wykonywanie poprzez opracowanie kodu pomocniczego w trakcie implementowania funkcjonalności opisanej w historyjce użytkownika. Testy akceptacyjne stają się wówczas wykonywalnymi wymaganiami.</b></p>`,
    flashcards:[
      {q:"ECP – co jest elementem pokrycia?", a:"Klasa równoważności (poprawna/niepoprawna)."},
      {q:"BVA 3‑punktowa – jakie wartości wokół progu?", a:"Wartość brzegowa oraz obie wartości sąsiednie (np. 9,10,11 dla progu 10)."},
      {q:"State transition – minimalne kryterium dla krytycznych systemów?", a:"Pokrycie wszystkich przejść (poprawnych i próby niepoprawnych)."},
      {q:"Pokrycie gałęzi a instrukcji – relacja?", a:"100% gałęzi subsumuje 100% instrukcji."}
    ],
    quiz:[
      {q:"W ECP elementem pokrycia jest…", opt:["Wartość brzegowa","Klasa równoważności","Ścieżka w kodzie","Przejście stanu"], a:1},
      {q:"Próg 10 (≤10 dozwolone). Który zestaw najlepiej pokrywa BVA 3‑punktowe?", opt:["8,9,10","9,10,11","10,11,12","0,10,20"], a:1},
      {q:"Co zapewni 100% pokrycia stanów?", opt:["Odpalimy wszystkie poprawne i niepoprawne przejścia","Odwiedzimy każdy stan co najmniej raz","Odwiedzimy każdy stan dokładnie raz","Sprawdzimy wszystkie wejścia/wyjścia"], a:1},
      {q:"Które stwierdzenie o pokryciu jest prawdziwe?", opt:["100% instrukcji ⇒ 100% gałęzi","100% gałęzi ⇒ 100% instrukcji","Żadne nie zachodzi","Zawsze potrzeba 100% ścieżek"], a:1},
      {q:"Co to jest technika czarnoskrzynkowa?", opt:["Analiza struktury wewnętrznej kodu","Analiza wyspecyfikowanego zachowania bez odwoływania się do struktury wewnętrznej","Testowanie oparte na doświadczeniu","Testowanie tylko automatyczne"], a:1, exp:"Techniki czarnoskrzynkowe bazują na analizie wyspecyfikowanego zachowania bez odwoływania się do struktury wewnętrznej."},
      {q:"Która technika NIE jest czarnoskrzynkowa?", opt:["Podział na klasy równoważności","Analiza wartości brzegowych","Testowanie przejść stanów","Pokrycie instrukcji"], a:3, exp:"Pokrycie instrukcji to technika białoskrzynkowa, pozostałe to techniki czarnoskrzynkowe."},
      {q:"Co to jest BVA dwupunktowa?", opt:["Testowanie tylko wartości brzegowych","Testowanie wartości brzegowej i jednej sąsiedniej","Testowanie trzech wartości wokół progu","Testowanie wszystkich możliwych wartości"], a:1, exp:"BVA dwupunktowa testuje wartość brzegową i jedną wartość sąsiednią (np. 9,10 dla progu 10)."},
      {q:"Które stwierdzenie o technikach opartych na doświadczeniu jest prawdziwe?", opt:["Są mniej skuteczne od technik czarnoskrzynkowych","Wykrywają defekty łatwe do przeoczenia w innych technikach","Wymagają znajomości kodu","Są zawsze automatyczne"], a:1, exp:"Techniki oparte na doświadczeniu wykrywają defekty łatwe do przeoczenia w technikach czarnoskrzynkowych i białoskrzynkowych."},
      {q:"Co to jest testowanie eksploracyjne?", opt:["Testowanie automatyczne","Testowanie oparte na doświadczeniu i eksperymentowaniu","Testowanie tylko funkcjonalne","Testowanie tylko niefunkcjonalne"], a:1, exp:"Testowanie eksploracyjne to technika oparta na doświadczeniu, łącząca projektowanie i wykonywanie testów."}
    ]
  },
  {
    id:"r5",
    title:"5. Zarządzanie czynnościami testowymi",
    read:`<h2>5. Zarządzanie czynnościami testowymi</h2>
      <p>Rozdział obejmuje praktyczne, szczegółowe wytyczne dotyczące planowania, zarządzania ryzykiem, monitorowania i nadzoru, zarządzania konfiguracją oraz zarządzania defektami — wraz z przykładami, metrykami i szablonami.</p>

      <h3>5.1 Planowanie testów</h3>
      <h4>5.1.1 Cel i treść planu testów</h4>
      <p><b>W planie testów opisuje się cele, zasoby i procesy związane z projektem testowania.</b> Plan testów:</p>
      <ul>
        <li>pozwala udokumentować sposób i harmonogram osiągania celów testów</li>
        <li>pomaga zagwarantować, że wykonywane czynności testowe spełnią ustalone kryteria</li>
        <li>służy do wymiany informacji z członkami zespołu i innymi interesariuszami</li>
        <li>pozwala wykazać, że testowanie będzie odbywać się zgodnie z dotychczasową polityką testów i strategią testów (bądź uzasadnić ewentualne odstępstwa od nich)</li>
      </ul>

      <p><b>Planowanie testów pozwala odpowiednio ukierunkować sposób myślenia testerów i zmusza ich do stawienia czoła przyszłym wyzwaniom związanym z ryzykami, harmonogramami, relacjami interpersonalnymi, narzędziami, kosztami, nakładami pracy itd.</b> Proces przygotowywania planu testów jest dobrą okazją do przemyślenia nakładów pracy, jakie będą niezbędne do osiągnięcia celów projektu testowania.</p>

      <p><b>Typowe zagadnienia poruszane w planie testów to między innymi:</b></p>
      <ul>
        <li><b>kontekst testowania</b> (np. zakres, cele testów i podstawa testów)</li>
        <li><b>założenia i ograniczenia</b> projektu testowania</li>
        <li><b>interesariusze</b> (np. role, obowiązki, istotność z punktu widzenia testowania, potrzeby w zakresie rekrutacji i szkoleń)</li>
        <li><b>wymiana informacji</b> (np. formy i częstotliwość wymiany informacji, szablony dokumentów)</li>
        <li><b>rejestr ryzyk</b> (np. ryzyk produktowych i projektowych)</li>
        <li><b>podejście do testowania</b> (np. poziomy testów, typy testów, techniki testowania, produkty pracy związane z testami, kryteria wejścia i wyjścia, niezależność testowania, gromadzone metryki, wymagania dotyczące danych testowych, wymagania dotyczące środowiska testowego, odstępstwa od polityki testów i strategii testów obowiązujących w organizacji)</li>
        <li><b>budżet i harmonogram</b></li>
      </ul>

      <p>Dokładniejsze informacje na temat planu testów i jego treści zawiera standard <b>ISO/IEC/IEEE 29119-3</b>.</p>

      <h4>5.1.2 Wkład testera w planowanie iteracji i wydań</h4>
      <p><b>W iteracyjnych cyklach wytwarzania oprogramowania występują zwykle dwa rodzaje planowania: planowanie wydań i planowanie iteracji.</b></p>

      <p><b>Planowanie wydań odbywa się w perspektywie wprowadzenia produktu do eksploatacji i obejmuje definiowanie/redefiniowanie backlogu produktu, a w pewnych przypadkach również doprecyzowanie większych historyjek użytkownika poprzez podzielenie ich na szereg mniejszych historyjek.</b> Opracowany w ten sposób plan jest też podstawą podejścia do testowania i planu testów we wszystkich iteracjach.</p>

      <p><b>Testerzy zaangażowani w planowanie wydań:</b></p>
      <ul>
        <li>piszą testowalne historyjki użytkownika i kryteria akceptacji (patrz podrozdział 4.5)</li>
        <li>uczestniczą w analizach ryzyka projektowego i produktowego (patrz podrozdział 5.2)</li>
        <li>szacują pracochłonność testowania związaną z historyjkami użytkownika (patrz sekcja 5.1.4)</li>
        <li>ustalają podejście do testowania</li>
        <li>planują testowanie w związku z danym wydaniem</li>
      </ul>

      <p><b>Planowanie iteracji odbywa się z kolei w perspektywie zakończenia pojedynczej iteracji produktu i dotyczy backlogu tej iteracji.</b> Testerzy zaangażowani w planowanie iteracji:</p>
      <ul>
        <li>uczestniczą w szczegółowej analizie ryzyka związanego z historyjkami użytkownika</li>
        <li>określają testowalność historyjek użytkownika</li>
        <li>dzielą historyjki użytkownika na zadania (w szczególności zadania testowe)</li>
        <li>szacują pracochłonność wszystkich zadań testowych</li>
        <li>identyfikują i doprecyzowują aspekty funkcjonalne i niefunkcjonalne przedmiotu testów</li>
      </ul>

      <h4>5.1.3 Kryteria wejścia i kryteria wyjścia</h4>
      <p><b>Kryteria wejścia określają warunki wstępne, które muszą zostać spełnione przed rozpoczęciem danej czynności.</b> W przypadku niespełnienia kryteriów wejścia wykonanie tej czynności może być trudniejsze oraz bardziej czasochłonne, kosztowne i ryzykowne. <b>Kryteria wyjścia określają warunki, które muszą zostać spełnione, aby można było uznać wykonywanie danej czynności za zakończone.</b> Kryteria wejścia i kryteria wyjścia należy zdefiniować w odniesieniu do każdego poziomu testów (kryteria te różnią się w zależności od celów testów).</p>

      <p><b>Typowe kryteria wejścia to między innymi:</b></p>
      <ul>
        <li><b>dostępność zasobów</b> (takich jak pracownicy, narzędzia, środowiska, dane testowe, budżet i czas)</li>
        <li><b>dostępność testaliów</b> (takich jak podstawa testów, testowalne wymagania, historyjki użytkownika i przypadki testowe)</li>
        <li><b>początkowy poziom jakości przedmiotu testów</b> (np. pomyślne przejście wszystkich testów dymnych)</li>
      </ul>

      <p><b>Typowe kryteria wyjścia to między innymi:</b></p>
      <ul>
        <li><b>miary staranności</b> (np. osiągnięty poziom pokrycia, liczba nieusuniętych defektów, gęstość defektów lub liczba niezaliczonych przypadków testowych)</li>
        <li><b>binarne kryteria „tak/nie"</b> (np. wykonanie zaplanowanych testów, wykonanie testowania statycznego, zgłoszenie wszystkich wykrytych defektów bądź zautomatyzowanie wszystkich testów regresji)</li>
      </ul>

      <p><b>Za poprawne kryterium wyjścia można także uznać przekroczenie terminu lub budżetu.</b> Zakończenie testowania w takich okolicznościach — nawet w przypadku niespełnienia innych kryteriów wyjścia — może być dopuszczalne, o ile interesariusze znają i akceptują ryzyko związane z wydaniem systemu bez dalszego testowania.</p>

      <p><b>W modelu zwinnego wytwarzania oprogramowania kryteria wyjścia są zwykle nazywane definicją ukończenia (ang. Definition of Done) i określają obiektywne metryki, zgodnie z którymi zespół może uznać dany element za nadający się do przekazania do eksploatacji.</b> Kryteria wejścia, które musi spełnić historyjka użytkownika, aby można było rozpocząć prace programistyczne i/lub czynności związane z testowaniem, są nazywane definicją gotowości (ang. Definition of Ready).</p>

      <h4>5.1.4 Techniki szacowania</h4>
      <p><b>Szacowanie pracochłonności testów polega na przewidywaniu nakładów pracy związanych z testowaniem, które są niezbędne do osiągnięcia celów projektu testowania.</b> Ważne jest przy tym uświadomienie interesariuszom, że oszacowania dokonuje się na podstawie szeregu założeń, w związku z czym jest ono zawsze obarczone błędem szacowania. Oszacowania są zwykle dokładniejsze w przypadku mniejszych zadań, dlatego przy szacowaniu dużych zadań należy rozbić takie zadania na szereg mniejszych elementów, co ułatwia określenie przewidywanego nakładu pracy.</p>

      <p><b>W niniejszym sylabusie opisano następujące cztery techniki szacowania:</b></p>

      <p><b>Szacowanie na podstawie proporcji.</b> W ramach tej techniki opartej na metrykach gromadzi się dane liczbowe z wcześniejszych projektów realizowanych w danej organizacji, co umożliwia ustalenie „standardowych" proporcji współczynników w odniesieniu do podobnych projektów. Współczynniki opisujące własne projekty danej organizacji (określone np. na podstawie danych historycznych) są co do zasady najlepszym źródłem informacji na potrzeby procesu szacowania. W oparciu o powyższe współczynniki standardowe można następnie oszacować pracochłonność nowego projektu. Na przykład jeśli w poprzednim projekcie proporcja pracochłonności wytwarzania do testowania oprogramowania wyniosła 3:2, a w bieżącym projekcie nakłady pracy na wytwarzanie mają wynieść 600 osobodni, to pracochłonność testowania można oszacować na poziomie 400 osobodni.</p>

      <p><b>Ekstrapolacja.</b> Podstawą tej techniki opartej na metrykach jest dokonywanie pomiarów na jak najwcześniejszym etapie bieżącego projektu w celu zebrania niezbędnych danych. Po dokonaniu wystarczającej liczby obserwacji pracochłonność pozostałych zadań można określić w przybliżeniu poprzez ekstrapolację dostępnych danych (zwykle z zastosowaniem modelu matematycznego). Metoda ta doskonale sprawdza się w iteracyjnych cyklach wytwarzania oprogramowania, w których zespół może na przykład ekstrapolować pracochłonność testów w nadchodzącej iteracji poprzez wyciągnięcie średniej z ostatnich trzech iteracji.</p>

      <p><b>Szerokopasmowa technika delficka.</b> W przypadku tej iteracyjnej techniki eksperckiej eksperci dokonują oszacowań na podstawie posiadanego doświadczenia. Każdy ekspert szacuje nakłady pracy samodzielnie (bez konsultacji z innymi). Następnie wyniki są zbierane i analizowane pod kątem występowania odchyleń wykraczających poza uzgodnione granice, a w przypadku wystąpienia takich odchyleń eksperci wspólnie omawiają bieżące oszacowania. Następnie każdy z ekspertów jest proszony o przygotowanie (również bez konsultacji z innymi ekspertami) nowego oszacowania na podstawie otrzymanych informacji zwrotnych. Proces ten jest powtarzany do momentu osiągnięcia konsensusu. Wariantem szerokopasmowej techniki delfickiej jest tzw. <b>poker planistyczny</b> — metoda powszechnie stosowana w zwinnym wytwarzaniu oprogramowania. W ramach tej metody oszacowań dokonuje się zwykle przy użyciu kart z liczbami odpowiadającymi wielkości nakładów pracy.</p>

      <p><b>Szacowanie trójpunktowe.</b> W przypadku tej techniki eksperckiej eksperci przygotowują trzy oszacowania: najbardziej optymistyczne (a), najbardziej prawdopodobne (m) i najbardziej pesymistyczne (b), a ostateczna szacowana wartość (E) jest ich średnią ważoną arytmetyczną. W najpopularniejszym wariancie tej techniki przewidywany nakład pracy oblicza się według wzoru: <b>E = (a + 4 × m + b) / 6</b>. Zaletą tej techniki jest fakt, że umożliwia ona ekspertom obliczenie błędu pomiaru: <b>SD = (b – a) / 6</b>. Na przykład jeśli szacowane wartości (w osobogodzinach) wynoszą a = 6, m = 9 i b = 18, to ostateczna szacowana wartość wynosi 10±2 osobogodzin (tj. od 8 do 12 osobogodzin), ponieważ E = (6 + 4 × 9 + 18) / 6 = 10, a SD = (18 – 6) / 6 = 2.</p>

      <p>Więcej informacji na temat tych i wielu innych technik szacowania testów można znaleźć w (Kan 2003, Koomen 2006, Westfall 2009).</p>

      <h4>5.1.5 Ustalanie priorytetów przypadków testowych</h4>
      <p><b>Po opracowaniu specyfikacji przypadków i procedur testowych oraz zgrupowaniu ich w zestawy testowe można utworzyć na ich podstawie harmonogram wykonywania testów, który określa kolejność, w jakiej mają być uruchamiane.</b> Przy ustalaniu priorytetów przypadków testowych należy uwzględnić różne czynniki. Poniżej opisano najczęściej stosowane strategie ustalania priorytetów przypadków testowych.</p>

      <p><b>Ustalanie priorytetów na podstawie ryzyka.</b> W przypadku tej strategii o kolejności wykonywania testów decydują wyniki analizy ryzyka (patrz sekcja 5.2.3). Jako pierwsze wykonywane są przypadki testowe pokrywające najważniejsze ryzyka.</p>

      <p><b>Ustalanie priorytetów na podstawie pokrycia.</b> W przypadku tej strategii kolejność wykonywania testów wynika z pokrycia (np. pokrycia instrukcji kodu). Jako pierwsze wykonywane są przypadki testowe pozwalające uzyskać największe pokrycie. W innym wariancie, zwanym ustalaniem priorytetów na podstawie dodatkowego pokrycia, jako pierwszy wykonywany jest przypadek testowy zapewniający największe pokrycie, a w następnej kolejności — przypadki zapewniające największe dodatkowe pokrycie.</p>

      <p><b>Ustalanie priorytetów na podstawie wymagań.</b> Zgodnie z tą strategią kolejność wykonywania testów ustala się na podstawie priorytetów wymagań, które można powiązać z odpowiadającymi im przypadkami testowymi. Priorytety wymagań określają w tym przypadku interesariusze. Jako pierwsze wykonywane są przypadki testowe związane z najważniejszymi wymaganiami.</p>

      <p><b>O ile jest to możliwe, przypadki testowe powinny być wykonywane w kolejności odpowiadającej poziomom priorytetów — na przykład z wykorzystaniem jednej z wyżej wymienionych strategii ustalania priorytetów.</b> Praktyka ta może jednak nie mieć zastosowania, jeśli przypadki testowe lub testowane przez nie cechy są uzależnione od innych elementów. Przykładem może być sytuacja, gdy przypadek testowy o wyższym priorytecie jest uzależniony od przypadku o niższym priorytecie — wówczas należy w pierwszej kolejności wykonać przypadek o niższym priorytecie.</p>

      <p><b>Przy ustalaniu kolejności wykonywania testów należy również wziąć pod uwagę dostępność zasobów.</b> Wynika to z faktu, że niektóre zasoby — takie jak niezbędne narzędzia lub środowiska testowe bądź pracownicy — mogą być dostępne tylko przez określony czas.</p>

      <h4>5.1.6 Piramida testów</h4>
      <p><b>Piramida testów to model odzwierciedlający fakt, że różne testy mogą mieć różną szczegółowość.</b> Model piramidy testów pomaga zespołowi w automatyzowaniu testów i określaniu ich pracochłonności poprzez wskazanie, że różne cele testów można osiągnąć przy zastosowaniu różnych poziomów automatyzacji.</p>

      <p><b>Poszczególne warstwy piramidy odpowiadają grupom testów — im wyższa warstwa, tym niższy poziom ich izolacji i dłuższy czas ich wykonywania.</b> Testy umieszczone w najniższej warstwie są małe, odizolowane i szybkie, a do tego sprawdzają niewielką część funkcjonalności, w związku z czym do uzyskania należytego pokrycia potrzebna jest zwykle ich bardzo duża liczba. W najwyższej warstwie znajdują się z kolei złożone i kompleksowe testy wysokiego poziomu. Ich wykonywanie zajmuje więcej czasu niż wykonywanie testów z niższych warstw, a sprawdzany przez nie obszar funkcjonalności jest szeroki, co oznacza, że do uzyskania należytego poziomu pokrycia wystarczy tylko kilka takich testów.</p>

      <p>Liczba i nazewnictwo warstw bywają różne. Na przykład w pierwotnym modelu piramidy testów (Cohn 2009) zdefiniowano trzy warstwy: „testy modułowe", „testy usług" i „testy interfejsu użytkownika", a w innym popularnym modelu określono testy modułowe, testy integracyjne (testy integracji modułów) i testy kompleksowe (ang. end-to-end). Mogą być również stosowane inne poziomy testów (patrz sekcja 2.2.1).</p>

      <h4>5.1.7 Kwadranty testowe</h4>
      <p><b>Kwadranty testowe, które zdefiniował jako pierwszy Brian Marick (Marick 2003, Crispin 2008), służą do grupowania poziomów testów wraz z odpowiednimi typami testów, czynnościami, technikami testowania i produktami pracy w kontekście zwinnego wytwarzania oprogramowania.</b> Model ten ułatwia zarządzanie testami poprzez wizualizowanie powyższych elementów — co zapewnia uwzględnienie wszystkich odpowiednich typów i poziomów testów w cyklu wytwarzania oprogramowania — oraz uświadamianie testerom, że niektóre typy testów są bardziej istotne niż inne na określonych poziomach testów. Dodatkową zaletą jest możliwość rozróżniania i opisywania poszczególnych typów testów na potrzeby wszystkich interesariuszy, w tym programistów, testerów i przedstawicieli jednostek biznesowych.</p>

      <p><b>W opisywanym modelu testy mogą mieć cel biznesowy lub technologiczny oraz mogą służyć wspieraniu zespołu (np. poprzez ukierunkowanie procesu wytwarzania oprogramowania) lub krytyce produktu (np. poprzez mierzenie jego zachowania względem oczekiwań).</b> Wypadkowa tych dwóch aspektów decyduje o przynależności do jednego z czterech kwadrantów:</p>

      <ul>
        <li><b>Kwadrant Q1 (cel technologiczny, wspieranie zespołu)</b> obejmuje testy modułowe i testy integracji modułów. Testy te powinny być wykonywane automatycznie i objęte procesem ciągłej integracji.</li>
        <li><b>Kwadrant Q2 (cel biznesowy, wspieranie zespołu)</b> obejmuje testy funkcjonalne, przykłady, testy oparte na historyjkach użytkownika, prototypy doświadczenia użytkownika, testowanie API oraz symulacje. Testy te sprawdzają spełnienie kryteriów akceptacji i mogą być wykonywane manualnie lub automatycznie.</li>
        <li><b>Kwadrant Q3 (cel biznesowy, krytyka produktu)</b> obejmuje testowanie eksploracyjne, testowanie użyteczności i testowanie akceptacyjne przez użytkownika. Testy te są ukierunkowane na użytkownika i często wykonywane manualnie.</li>
        <li><b>Kwadrant Q4 (cel technologiczny, krytyka produktu)</b> obejmuje testy dymne i testy niefunkcjonalne (z wyłączeniem testów użyteczności). Testy te są często wykonywane automatycznie.</li>
      </ul>

      <h3>5.2 Zarządzanie ryzykiem</h3>
      <p>Organizacje mają do czynienia z wieloma czynnikami wewnętrznymi i zewnętrznymi, które wywołują niepewność co do tego, czy i kiedy zostaną osiągnięte zakładane cele (ISO 31000). <b>Zarządzanie ryzykiem to proces, który umożliwia organizacjom zwiększanie prawdopodobieństwa osiągnięcia celów i podnoszenie jakości produktów, a także budowanie zaufania interesariuszy.</b></p>

      <p><b>Najważniejsze działania związane z zarządzaniem ryzykiem to:</b></p>
      <ul>
        <li><b>analiza ryzyka</b> (obejmująca identyfikację ryzyka i ocenę ryzyka; patrz sekcja 5.2.3)</li>
        <li><b>kontrola ryzyka</b> (obejmująca łagodzenie ryzyka i monitorowanie ryzyka; patrz sekcja 5.2.4)</li>
      </ul>

      <p><b>Podejście do testowania, zgodnie z którym podstawą doboru czynności testowych i ustalania ich priorytetów oraz zarządzania nimi są analiza ryzyka i kontrola ryzyka, jest nazywane testowaniem opartym na ryzyku.</b></p>

      <h4>5.2.1 Definicja i atrybuty ryzyka</h4>
      <p><b>Ryzyko to potencjalne zdarzenie, niebezpieczeństwo, zagrożenie bądź sytuacja, którego lub której wystąpienie powoduje niekorzystny skutek.</b> Do charakteryzowania ryzyka służą dwa parametry:</p>
      <ul>
        <li><b>prawdopodobieństwo ryzyka</b>, czyli prawdopodobieństwo wystąpienia danego ryzyka (większe niż zero i mniejsze niż jeden)</li>
        <li><b>wpływ ryzyka (szkoda)</b>, czyli konsekwencje wystąpienia danego ryzyka</li>
      </ul>

      <p><b>Powyższe dwa parametry wyrażają poziom ryzyka, który jest miarą wielkości danego ryzyka: im wyższy poziom ryzyka, tym ważniejsze jest podjęcie działań zaradczych.</b></p>

      <h4>5.2.2 Ryzyka projektowe i produktowe</h4>
      <p><b>W testowaniu oprogramowania istotne są zasadniczo dwa typy ryzyk: ryzyka projektowe oraz ryzyka produktowe.</b></p>

      <p><b>Ryzyka projektowe są związane z zarządzaniem projektem i nadzorem nad jego realizacją.</b> Do ryzyk projektowych należą:</p>
      <ul>
        <li><b>problemy organizacyjne</b> (np. opóźnienia w dostawach produktów pracy, niedokładne oszacowania lub cięcia finansowe)</li>
        <li><b>problemy kadrowe</b> (np. niewystarczające umiejętności, konflikty, problemy z wymianą informacji lub braki kadrowe)</li>
        <li><b>problemy techniczne</b> (np. nieplanowane rozszerzanie zakresu projektu lub niedostateczna obsługa narzędzi)</li>
        <li><b>problemy związane z dostawcami</b> (np. niedostarczenie niezbędnego elementu przez zewnętrznego dostawcę lub ogłoszenie upadłości przez firmę świadczącą usługi wsparcia technicznego)</li>
      </ul>

      <p>Wystąpienie ryzyka projektowego może mieć wpływ na harmonogram realizacji, budżet lub zakres projektu, a tym samym na możliwość osiągnięcia jego celów.</p>

      <p><b>Ryzyka produktowe są związane z charakterystykami jakościowymi produktu (opisanymi np. w modelu jakości określonym przez standard ISO 25010).</b> Przykładami ryzyka produktowego mogą być następujące problemy: brakujące lub niewłaściwe elementy funkcjonalności, niepoprawne obliczenia, awarie podczas wykonywania programu, niedopracowana architektura, nieefektywne algorytmy, zbyt długi czas odpowiedzi, niski poziom doświadczenia użytkownika (ang. User Experience — UX) lub podatności na zagrożenia zabezpieczeń.</p>

      <p><b>Wystąpienie ryzyka produktowego może pociągać za sobą cały szereg negatywnych konsekwencji, takich jak:</b></p>
      <ul>
        <li>niezadowolenie użytkowników</li>
        <li>utrata przychodów, zaufania lub reputacji</li>
        <li>szkody wyrządzone stronom trzecim</li>
        <li>wysokie koszty pielęgnacji i przeciążenie struktur wsparcia technicznego</li>
        <li>odpowiedzialność karna</li>
        <li>w skrajnych przypadkach — szkody materialne, uszczerbek na zdrowiu, a nawet śmierć</li>
      </ul>

      <h4>5.2.3 Analiza ryzyka produktowego</h4>
      <p><b>Z perspektywy testowania celem analizy ryzyka produktowego jest uzyskanie wiedzy na temat tego rodzaju ryzyka i wykorzystanie jej do ukierunkowania działań wykonywanych podczas testowania w sposób pozwalający zminimalizować poziom ryzyka rezydualnego (resztkowego).</b> Analizę ryzyka produktowego należy w miarę możliwości rozpocząć na wczesnym etapie cyklu wytwarzania oprogramowania.</p>

      <p><b>Analiza ryzyka produktowego obejmuje identyfikację ryzyka i ocenę ryzyka.</b> Identyfikacja ryzyka polega na wygenerowaniu wyczerpującej listy ryzyk, przy czym interesariusze mogą identyfikować takie ryzyka za pomocą różnych technik i narzędzi, takich jak burza mózgów, warsztaty, wywiady i diagramy przyczynowo-skutkowe. Ocena ryzyka obejmuje z kolei sklasyfikowanie zidentyfikowanych ryzyk, ustalenie prawdopodobieństwa, wpływu i poziomu ryzyka oraz ustalenie priorytetów ryzyk i zaproponowanie sposobów postępowania z nimi. Klasyfikacja ułatwia przypisanie odpowiednich działań związanych z łagodzeniem ryzyka, ponieważ ryzyka zaliczane do tej samej kategorii można zwykle łagodzić podobnymi sposobami.</p>

      <p><b>Oceny ryzyka można dokonać metodą ilościową, jakościową bądź mieszaną.</b> W przypadku podejścia ilościowego poziom ryzyka oblicza się jako iloczyn prawdopodobieństwa ryzyka i wpływu ryzyka, natomiast podejście jakościowe przewiduje ustalanie poziomu ryzyka przy użyciu macierzy ryzyka.</p>

      <p><b>Analiza ryzyka produktowego może mieć wpływ na staranność i zakres testowania. Jej wyniki wykorzystuje się do:</b></p>
      <ul>
        <li>określenia zakresu wykonywanych testów</li>
        <li>ustalenia konkretnych poziomów testów i zaproponowania typów testów, jakie mają zostać wykonane</li>
        <li>wskazania odpowiednich technik testowania i zakładanego poziomu pokrycia</li>
        <li>oszacowania pracochłonności testowania w odniesieniu do każdego zadania</li>
        <li>ustalenia priorytetów testowania w sposób sprzyjający jak najwcześniejszemu wykryciu defektów krytycznych</li>
        <li>ustalenia, czy w celu zmniejszenia ryzyka należy wykonać dodatkowe czynności (poza samym testowaniem)</li>
      </ul>

      <h4>5.2.4 Kontrola ryzyka produktowego</h4>
      <p><b>Kontrola ryzyka produktowego obejmuje wszystkie środki podejmowane w odpowiedzi na zidentyfikowane i ocenione ryzyka produktowe.</b> W ramach kontroli ryzyka produktowego wyróżnia się łagodzenie ryzyka i monitorowanie ryzyka. Łagodzenie ryzyka polega na wykonywaniu działań zaproponowanych na etapie oceny ryzyka w celu obniżenia jego poziomu, natomiast celem monitorowania ryzyka jest zapewnienie skuteczności działań związanych z łagodzeniem ryzyka, uzyskanie dalszych informacji pozwalających usprawnić proces oceny ryzyka oraz zidentyfikowanie nowych ryzyk.</p>

      <p><b>Po przeanalizowaniu danego ryzyka proces kontroli ryzyka produktowego przewiduje kilka wariantów, takich jak: łagodzenie ryzyka poprzez testowanie, akceptacja ryzyka, przeniesienie ryzyka oraz plany awaryjne</b> (Veenendaal 2012).</p>

      <p><b>Działania, które można podjąć w celu łagodzenia ryzyka produktowego poprzez testowanie, obejmują:</b></p>
      <ul>
        <li>wytypowanie testerów dysponujących właściwym poziomem doświadczenia i umiejętności — adekwatnie do danego typu ryzyka</li>
        <li>zapewnienie odpowiedniego poziomu niezależności testowania</li>
        <li>przeprowadzenie przeglądów i analizy statycznej</li>
        <li>zastosowanie odpowiednich technik testowania i poziomów pokrycia</li>
        <li>zastosowanie odpowiednich typów testów uwzględniających charakterystyki jakościowe, których dotyczy ryzyko</li>
        <li>wykonanie testowania dynamicznego, w tym testowania regresji</li>
      </ul>

      <h3>5.3 Monitorowanie testów, nadzór nad testami i ukończenie testów</h3>
      <p><b>Celem monitorowania testów jest gromadzenie informacji na temat przebiegu procesu testowania.</b> Informacje te są wykorzystywane do oceny postępu testów oraz do pomiaru spełnienia kryteriów wyjścia lub wykonania związanych z nimi zadań testowych (takich jak osiągnięcie zakładanego pokrycia ryzyk produktowych, wymagań lub kryteriów akceptacji).</p>

      <p><b>W ramach nadzoru nad testami informacje uzyskane w procesie monitorowania testów są wykorzystywane do określenia (w formie dyrektyw nadzoru) niezbędnych działań korygujących, które pozwolą uzyskać maksymalną skuteczność i efektywność testowania.</b> Dyrektywy nadzoru mogą obejmować na przykład:</p>
      <ul>
        <li>ponowne ustalenie priorytetów testów w przypadku wystąpienia problemów wynikających ze zidentyfikowanego ryzyka</li>
        <li>dokonanie ponownej oceny elementu testowego pod kątem spełnienia kryteriów wejścia lub wyjścia w związku z wprowadzeniem poprawek</li>
        <li>wprowadzenie zmian w harmonogramie testów w związku z opóźnieniami w realizacji środowiska testowego</li>
        <li>dodanie nowych zasobów w zależności od bieżących potrzeb</li>
      </ul>

      <p><b>Ukończenie testów polega na zebraniu danych pochodzących z wykonanych czynności testowych w celu usystematyzowania i połączenia zdobytych doświadczeń, testaliów i innych istotnych informacji.</b> Czynności związane z ukończeniem testów są wykonywane w momencie osiągnięcia kamieni milowych projektu, takich jak: ukończenie testów danego poziomu, zakończenie iteracji projektu zwinnego, zakończenie realizacji (lub anulowanie) projektu testowania, przekazanie systemu oprogramowania do eksploatacji bądź zakończenie prac nad wydaniem pielęgnacyjnym (ang. maintenance release).</p>

      <h4>5.3.1 Metryki stosowane w testowaniu</h4>
      <p><b>Metryki dotyczące testów gromadzi się w celu określenia postępu realizacji harmonogramu i budżetu, bieżącej jakości przedmiotu testów oraz skuteczności czynności testowych z punktu widzenia realizacji celów testów lub celu iteracji.</b> W ramach monitorowania testów zbiera się wiele metryk przydatnych w kontekście nadzoru nad testami i ukończenia testów.</p>

      <p><b>Powszechnie stosowane są między innymi następujące metryki dotyczące testów:</b></p>
      <ul>
        <li><b>metryki dotyczące postępu realizacji projektu</b> (np. ukończenie zadań, użycie zasobów, pracochłonność testowania)</li>
        <li><b>metryki dotyczące postępu testów</b> (np. postęp implementacji przypadków testowych, postęp przygotowania środowiska testowego, liczba wykonanych/niewykonanych i zaliczonych/niezaliczonych przypadków testowych, czas wykonywania testów)</li>
        <li><b>metryki dotyczące jakości produktów</b> (np. dostępność, czas odpowiedzi, średni czas do awarii)</li>
        <li><b>metryki dotyczące defektów</b> (np. liczba i priorytety wykrytych/usuniętych defektów, gęstość defektów, odsetek wykrytych defektów)</li>
        <li><b>metryki dotyczące ryzyka</b> (np. poziom ryzyka rezydualnego)</li>
        <li><b>metryki dotyczące pokrycia</b> (np. pokrycie wymagań, pokrycie kodu)</li>
        <li><b>metryki dotyczące kosztów</b> (np. koszty testowania, koszt jakości na poziomie organizacji)</li>
      </ul>

      <h4>5.3.2 Cel, treść i odbiorcy raportów z testów</h4>
      <p><b>Raporty z testów służą do podsumowywania i przekazywania informacji na temat testów w trakcie testowania i po jego zakończeniu.</b> Raporty o postępie testów są elementem ciągłego nadzoru nad testami, w związku z czym zawarte w nich informacje muszą być na tyle obszerne, aby w razie potrzeby umożliwić modyfikację harmonogramu testów, przydziału zasobów lub planu testów — na przykład w związku z odstępstwami od planu lub zmieniającymi się okolicznościami. <b>Sumaryczne raporty z testów stanowią podsumowanie określonego etapu testowania (np. poziomu testów, cyklu testowego lub iteracji) i mogą dostarczać informacji na potrzeby dalszego testowania.</b></p>

      <p><b>W ramach monitorowania testów i nadzoru nad testami, zespół testowy sporządza raporty o postępie testów, aby zapewnić interesariuszom stały dostęp do informacji.</b> Raporty takie są zazwyczaj sporządzane regularnie (np. raz dziennie, raz w tygodniu itp.) i zawierają informacje na temat:</p>
      <ul>
        <li>okresu testowania</li>
        <li>postępu testów (np. wykonania zadań przed terminem lub po terminie), w tym wszelkich istotnych odchyleń</li>
        <li>utrudnień w testowaniu i sposobów ich obejścia</li>
        <li>metryk dotyczących testów (przykłady podano w sekcji 5.3.1)</li>
        <li>nowych i zmienionych ryzyk zaobserwowanych w okresie testowania</li>
        <li>testów zaplanowanych na następny okres</li>
      </ul>

      <p><b>Sumaryczny raport z testów jest sporządzany na etapie ukończenia testów — po zakończeniu realizacji projektu bądź po wykonaniu testów danego poziomu lub typu, iteracji oraz, w sytuacji idealnej, po spełnieniu kryteriów wyjścia.</b> W raporcie tym wykorzystywane są dane z raportów o postępie testów oraz inne dane.</p>

      <p><b>Typowy sumaryczny raport z testów zawiera między innymi:</b></p>
      <ul>
        <li>podsumowanie testów</li>
        <li>ocenę jakości testowania i produktu z punktu widzenia pierwotnego planu testów (tj. celów testów i kryteriów wyjścia)</li>
        <li>informacje o odstępstwach od planu testów (np. o różnicach w stosunku do pierwotnie zakładanego harmonogramu, czasu trwania i nakładu pracy)</li>
        <li>informacje o utrudnieniach w testowaniu i sposobach ich obejścia</li>
        <li>metryki dotyczące testów określone na podstawie raportów o postępie testów</li>
        <li>informacje o niezłagodzonych ryzykach i nieusuniętych defektach</li>
        <li>zdobyte doświadczenia, które są istotne z punktu widzenia testowania</li>
      </ul>

      <p><b>Poszczególne grupy odbiorców mają różne wymagania co do zakresu informacji podawanych w raportach, a także różne oczekiwania co do stopnia sformalizowania i częstotliwości przekazywania raportów.</b> Wymiana informacji o postępie testów w obrębie zespołu odbywa się zwykle z dużą częstotliwością i na stopie nieformalnej, natomiast raport na temat testowania dotyczący ukończonego projektu jest sporządzany zgodnie z określonym wzorem i przedstawiany tylko raz.</p>

      <p>Szablony i przykłady raportów o postępie testów (nazywanych raportami o statusie testów) oraz sumarycznych raportów z testów zawiera standard <b>ISO/IEC/IEEE 29119-3</b>.</p>

      <h4>5.3.3 Przekazywanie informacji o statusie testowania</h4>
      <p><b>Optymalny sposób przekazywania informacji o statusie testów zależy od uwarunkowań związanych z zarządzaniem testami, strategii testów przyjętej w danej organizacji i obowiązujących norm prawnych, a w przypadku samoorganizujących się zespołów (patrz sekcja 1.5.2) — również od samego zespołu.</b></p>

      <p><b>Dostępne są między innymi następujące opcje:</b></p>
      <ul>
        <li>słowna wymiana informacji z członkami zespołu i innymi interesariuszami</li>
        <li><b>tablice wskaźników (ang. dashboard)</b>, np. tablice wskaźników dotyczące ciągłej integracji lub ciągłego dostarczania, tablice zadań i wykresy spalania</li>
        <li>kanały komunikacji elektronicznej, np. e-mail czy chat</li>
        <li>dokumentacja w formie elektronicznej</li>
        <li>formalne raporty z testów (patrz sekcja 5.3.2)</li>
      </ul>

      <p>Zależnie od sytuacji można stosować jedną lub kilka z powyższych opcji. W przypadku rozproszonych zespołów, w których bezpośrednie rozmowy nie zawsze są możliwe z uwagi na odległość czy różnicę czasu, lepszym rozwiązaniem może być bardziej formalna wymiana informacji. Ponadto różni interesariusze są zwykle zainteresowani różnymi informacjami, w związku z czym ważne jest odpowiednie dostosowanie treści przekazywanych komunikatów.</p>

      <h3>5.4 Zarządzanie konfiguracją</h3>
      <p><b>W kontekście testowania zarządzanie konfiguracją to uporządkowany proces umożliwiający identyfikowanie, nadzorowanie i śledzenie produktów pracy, takich jak: plany testów, strategie testów, warunki testowe, przypadki testowe, skrypty testowe, wyniki testów, dzienniki testów oraz raporty z testów.</b> W ramach tego procesu powyższe produkty pracy są nazywane elementami konfiguracji.</p>

      <p><b>W przypadku złożonego elementu konfiguracji (np. środowiska testowego) zarządzanie konfiguracją pozwala zarejestrować również jego elementy składowe wraz z informacją o relacjach między takimi elementami i ich wersjach.</b> Element konfiguracji, który został zatwierdzony do testowania, staje się konfiguracją bazową i może być modyfikowany wyłącznie w ramach formalnego procesu nadzoru nad zmianami.</p>

      <p><b>W przypadku utworzenia nowej konfiguracji bazowej zmodyfikowane elementy konfiguracji są dokumentowane, aby umożliwić powrót do poprzedniej konfiguracji bazowej w celu odtworzenia wcześniejszych wyników testów.</b></p>

      <p><b>Zarządzanie konfiguracją umożliwia sprawny przebieg testowania poprzez zagwarantowanie, że:</b></p>
      <ul>
        <li><b>wszystkie elementy konfiguracji, w tym elementy testowe (tj. poszczególne elementy przedmiotu testów), są jednoznacznie identyfikowane, objęte kontrolą wersji i śledzeniem zmian oraz powiązane z innymi elementami konfiguracji w sposób pozwalający utrzymać możliwość śledzenia na wszystkich etapach procesu testowego</b></li>
        <li><b>wszystkie zidentyfikowane dokumenty i elementy oprogramowania są przywoływane w sposób jednoznaczny w testaliach</b></li>
      </ul>

      <p><b>Ciągła integracja, ciągłe dostarczanie i ciągłe wdrażanie oraz związane z nimi procesy testowania są zwykle realizowane w ramach zautomatyzowanego potoku DevOps (patrz sekcja 2.1.4), który standardowo obejmuje również zautomatyzowane zarządzanie konfiguracją.</b></p>

      <h3>5.5 Zarządzanie defektami</h3>
      <p><b>Z uwagi na to, że jednym z głównych celów testów jest wykrywanie defektów, niezbędny jest ustalony proces zarządzania defektami.</b> Chociaż w tym podrozdziale jest mowa o „defektach", zgłaszane anomalie mogą okazać się zarówno rzeczywistymi defektami, jak i czymś zupełnie innym (np. rezultatami fałszywie pozytywnymi lub żądaniami zmiany). Wszelkie wątpliwości w tym zakresie są rozstrzygane podczas rozpatrywania raportów o defektach. Anomalie mogą być zgłaszane w dowolnej fazie cyklu wytwarzania oprogramowania, a sposób ich zgłaszania zależy od konkretnego cyklu.</p>

      <p><b>Nieodzownymi elementami procesu zarządzania defektami są: przepływ pracy umożliwiający obsługę poszczególnych defektów lub anomalii od momentu ich wykrycia do momentu zamknięcia zgłoszenia oraz reguły klasyfikacji takich defektów lub anomalii.</b> Na powyższy przepływ pracy składają się czynności związane z rejestrowaniem, analizowaniem i klasyfikowaniem zgłaszanych anomalii, podejmowaniem decyzji o właściwym sposobie reagowania (usunięcie problemu, pozostawienie bez zmian) oraz zamykaniem raportów o defektach. Ustalonej procedury muszą przestrzegać wszyscy zaangażowani interesariusze. Podobny sposób postępowania jest również zalecany w przypadku defektów wykrytych w trakcie testowania statycznego (a zwłaszcza analizy statycznej).</p>

      <p><b>Typowy raport o defekcie ma na celu:</b></p>
      <ul>
        <li>dostarczenie osobom, które są odpowiedzialne za obsługę i usuwanie zgłoszonych defektów, informacji wystarczających do rozwiązania problemu</li>
        <li>umożliwienie śledzenia jakości produktu pracy</li>
        <li>przedstawienie sugestii dotyczących usprawnienia procesu wytwarzania oprogramowania i procesu testowego</li>
      </ul>

      <p><b>Raport o defekcie rejestrowany podczas testowania dynamicznego zawiera zwykle następujące informacje:</b></p>
      <ul>
        <li><b>jednoznaczny identyfikator</b></li>
        <li><b>tytuł i krótkie podsumowanie zgłaszanej anomalii</b></li>
        <li><b>data zaobserwowania anomalii, zgłaszająca jednostka organizacyjna i autor zgłoszenia (w tym jego rola)</b></li>
        <li><b>identyfikacja przedmiotu testów i środowiska testowego</b></li>
        <li><b>kontekst wystąpienia defektu</b> (np. uruchamiany przypadek testowy, wykonywana czynność testowa, faza cyklu wytwarzania oprogramowania oraz inne istotne informacje, takie jak stosowana technika testowania, lista kontrolna czy dane testowe)</li>
        <li><b>opis awarii umożliwiający jej odtworzenie i usunięcie</b> (w tym kroki testowe, które umożliwiły wykrycie anomalii) oraz wszelkie istotne dzienniki testów, zrzuty baz danych, zrzuty ekranu lub nagrania</li>
        <li><b>oczekiwane i rzeczywiste rezultaty</b></li>
        <li><b>krytyczność (stopień wpływu) defektu z punktu widzenia interesariuszy lub wymagań</b></li>
        <li><b>priorytet usunięcia</b></li>
        <li><b>status defektu</b> (np. otwarty, odroczony, powielony, oczekujący na poprawkę, oczekujący na testowanie potwierdzające, ponownie otwarty, zamknięty, odrzucony)</li>
        <li><b>odwołania do innych elementów</b> (np. do przypadku testowego)</li>
      </ul>

      <p>Niektóre z powyższych danych (np. identyfikator, data, autor i początkowy status) mogą zostać uwzględnione automatycznie w przypadku korzystania z narzędzi do zarządzania defektami. Szablony raportów o defektach i przykładowe raporty tego typu przedstawiono w standardzie <b>ISO/IEC/IEEE 29119-3</b> (raporty o defektach są w nim nazywane raportami o incydentach).</p>`,
    flashcards:[
      {q:"Wymień 3 elementy planu testów.", a:"Kontekst i zakres; role/odpowiedzialności; podejście i kryteria; rejestr ryzyk; budżet i harmonogram; komunikacja."},
      {q:"Czym jest Definition of Done / Ready?", a:"DoD – kryteria wyjścia dla elementu; DoR – kryteria wejścia, by rozpocząć pracę nad historyjką."},
      {q:"Podaj 2 techniki estymacji.", a:"Np. proporcje, ekstrapolacja, delficka/poker, trójpunktowa (E=(a+4m+b)/6)."},
      {q:"Ryzyka produktowe vs. projektowe – przykład.", a:"Produktowe: błędy jakości (np. bezpieczeństwo). Projektowe: opóźnienia, braki zasobów."}
    ],
    quiz:[
      {q:"Który element nie należy do typowej treści planu testów?", opt:["Rejestr ryzyk","Budżet","Szczegóły implementacji baz danych","Kryteria wejścia/wyjścia"], a:2},
      {q:"W technice trójpunktowej przy a=6, m=9, b=18 – E wynosi?", opt:["9","10","11","12"], a:1, exp:"E=(6+4*9+18)/6=10."},
      {q:"Która strategia priorytetyzacji wykonuje najpierw testy o największym wkładzie w pokrycie?", opt:["Wg wymagań","Wg ryzyka","Wg dodatkowego pokrycia","Losowa"], a:2},
      {q:"Które zdanie o ryzyku jest prawdziwe?", opt:["Poziom ryzyka to iloczyn prawdopodobieństwa i wpływu","Ryzyka dotyczą tylko projektu, nie produktu","Ocena ryzyka nie wpływa na testy","Ryzyka ustala wyłącznie kierownik projektu"], a:0},
      {q:"Co to jest Definition of Done (DoD)?", opt:["Kryteria wejścia dla historyjki","Kryteria wyjścia dla elementu","Plan testów","Strategia testów"], a:1, exp:"Definition of Done to kryteria wyjścia określające, kiedy element jest gotowy do przekazania."},
      {q:"Które stwierdzenie o monitorowaniu testów jest prawdziwe?", opt:["Nie wymaga metryk","Pozwala na korekty w trakcie projektu","Jest opcjonalne","Dotyczy tylko automatycznych testów"], a:1, exp:"Monitorowanie testów pozwala na korekty w trakcie projektu na podstawie zebranych informacji."},
      {q:"Co to jest zarządzanie konfiguracją?", opt:["Zarządzanie zespołem testowym","Zarządzanie wersjami produktów pracy","Zarządzanie budżetem","Zarządzanie harmonogramem"], a:1, exp:"Zarządzanie konfiguracją to zarządzanie wersjami produktów pracy i ich powiązaniami."},
      {q:"Które stwierdzenie o zarządzaniu defektami jest prawdziwe?", opt:["Defekty są zawsze usuwane natychmiast","Proces obejmuje identyfikację, dokumentowanie i śledzenie","Dotyczy tylko krytycznych defektów","Nie wymaga priorytetyzacji"], a:1, exp:"Zarządzanie defektami obejmuje identyfikację, dokumentowanie, priorytetyzację i śledzenie defektów."},
      {q:"Co to jest testowanie oparte na ryzyku?", opt:["Testowanie tylko krytycznych funkcji","Priorytetyzacja testów wg zidentyfikowanych ryzyk","Testowanie tylko automatyczne","Testowanie tylko manualne"], a:1, exp:"Testowanie oparte na ryzyku to priorytetyzacja testów wg zidentyfikowanych ryzyk produktowych i projektowych."}
    ]
  },
  {
    id:"r6",
    title:"6. Narzędzia testowe",
    read:`<h2>6. Narzędzia testowe</h2>
      <h3>6.1 Narzędzia wspomagające testowanie</h3>
      <p><b>Narzędzia testowe wspomagają i ułatwiają wykonywanie wielu czynności testowych.</b> Dostępne są między innymi następujące narzędzia:</p>

      <p><b>● narzędzia do zarządzania</b> — zwiększające efektywność procesu testowego poprzez ułatwienie zarządzania cyklem wytwarzania oprogramowania, wymaganiami, testami, defektami i konfiguracją</p>

      <p><b>● narzędzia do testowania statycznego</b> — pomagające testerom w przeprowadzaniu przeglądów i analizy statycznej</p>

      <p><b>● narzędzia do projektowania testów i implementacji testów</b> — ułatwiające tworzenie przypadków, danych i procedur testowych</p>

      <p><b>● narzędzia do wykonywania testów i pomiaru pokrycia</b> — ułatwiające automatyczne wykonywanie testów i mierzenie pokrycia</p>

      <p><b>● narzędzia do testowania niefunkcjonalnego</b> — umożliwiające testerom wykonywanie testów niefunkcjonalnych, które są trudne lub niemożliwe do wykonania w trybie manualnym</p>

      <p><b>● narzędzia DevOps</b> — wspomagające działanie potoku dostarczania, śledzenie przepływu pracy, wykonywanie zautomatyzowanych procesów budowania oraz funkcjonowanie mechanizmów ciągłej integracji i ciągłego dostarczania w metodyce DevOps</p>

      <p><b>● narzędzia wspomagające współpracę</b> — ułatwiające wymianę informacji</p>

      <p><b>● narzędzia zwiększające skalowalność i standaryzację wdrażania</b> (np. maszyny wirtualne lub narzędzia do konteneryzacji)</p>

      <p><b>● wszelkie inne narzędzia wspomagające testowanie</b> (np. w kontekście testowania narzędziem testowym może być również arkusz kalkulacyjny)</p>

      <h3>6.2 Korzyści i ryzyka związane z automatyzacją testów</h3>
      <p><b>Sam zakup narzędzia nie gwarantuje jeszcze sukcesu.</b> Osiągnięcie realnych i trwałych korzyści z wdrożenia nowego narzędzia zawsze wymaga dodatkowego wysiłku (związanego np. z wprowadzeniem i utrzymaniem takiego narzędzia oraz przeprowadzeniem związanych z nim szkoleń). Ponadto należy również uwzględnić pewne ryzyka, które wymagają przeanalizowania i złagodzenia.</p>

      <p><b>Potencjalne korzyści wynikające z automatyzacji testów to między innymi:</b></p>

      <p><b>● oszczędność czasu poprzez ograniczenie powtarzalnych czynności wykonywanych manualnie</b> (takich jak uruchamianie testów regresji, wielokrotne wprowadzanie tych samych danych testowych, porównywanie rzeczywistych rezultatów z oczekiwanymi czy sprawdzanie zgodności ze standardami tworzenia kodu)</p>

      <p><b>● zapobieganie prostym błędom ludzkim poprzez zwiększenie spójności i powtarzalności</b> (np. poprzez wyprowadzanie testów w spójny sposób z wymagań, systematyczne tworzenie danych testowych oraz wykonywanie testów przy użyciu narzędzia w tej samej kolejności i z tą samą częstotliwością)</p>

      <p><b>● bardziej obiektywna ocena (np. w zakresie pokrycia) i przeprowadzanie pomiarów, które są zbyt skomplikowane, aby mogły zostać określone przez ludzi</b></p>

      <p><b>● łatwiejszy dostęp do informacji na temat testowania, które ułatwiają zarządzanie testami i raportowanie na temat testów</b> (np. danych statystycznych, wykresów i zagregowanych danych obrazujących postęp testów, współczynników występowania awarii oraz danych dotyczących czasu trwania wykonywanych testów)</p>

      <p><b>● skrócenie czasu wykonywania testów, co przekłada się na wcześniejsze wykrywanie defektów oraz szybsze przekazywanie informacji zwrotnych i wprowadzanie produktów na rynek</b></p>

      <p><b>● zapewnienie testerom dodatkowego czasu na projektowanie nowych, bardziej wnikliwych i skuteczniejszych testów</b></p>

      <p><b>Do potencjalnych ryzyk związanych z automatyzacją testów należą:</b></p>

      <p><b>● nierealistyczne oczekiwania co do korzyści wynikających z zastosowania narzędzia</b> (w tym funkcjonalności i łatwości obsługi)</p>

      <p><b>● niedokładne oszacowanie czasu, kosztów i nakładów pracy związanych z wprowadzeniem narzędzia, utrzymaniem skryptów testowych oraz zmianą dotychczasowego manualnego procesu testowego</b></p>

      <p><b>● stosowanie narzędzia w sytuacjach, w których lepiej sprawdzi się testowanie manualne</b></p>

      <p><b>● nadmierne uzależnienie od narzędzia</b> (np. lekceważenie potrzeby krytycznego myślenia)</p>

      <p><b>● uzależnienie od dostawcy narzędzia, który może zakończyć działalność, wycofać narzędzie lub sprzedać je innemu dostawcy bądź świadczyć niskiej jakości usługi wsparcia technicznego</b> (np. w zakresie reagowania na zapytania, dostarczania uaktualnień lub usuwania defektów)</p>

      <p><b>● korzystanie z oprogramowania open source, które może zostać porzucone</b> (co oznacza brak dalszych aktualizacji) lub którego elementy wewnętrzne mogą wymagać stosunkowo częstych aktualizacji w związku z dalszymi pracami rozwojowymi</p>

      <p><b>● brak kompatybilności narzędzia do automatyzacji z daną platformą programistyczną</b></p>

      <p><b>● wybór nieodpowiedniego narzędzia, które nie spełnia wymogów prawnych i/lub norm bezpieczeństwa</b></p>`,
    flashcards:[
      {q:"Podaj 2 korzyści automatyzacji.", a:"Szybsza regresja i powtarzalność; spójne środowiska; ślad audytu."},
      {q:"Podaj jedno ryzyko automatyzacji.", a:"Koszty utrzymania, kruchość testów UI, nietrafiony dobór narzędzi."}
    ],
    quiz:[
      {q:"Które stwierdzenie o automatyzacji jest najbliższe prawdy?", opt:["Zawsze się opłaca","Zastępuje całkowicie testy manualne","Wymaga inwestycji i nie eliminuje testów manualnych","Dotyczy tylko testów UI"], a:2}
    ]
  }
];

/** -------------------------------------------------------
 *  PYTANIA EGZAMINACYJNE – CTFL Sample Exam A (40) z przypisaniem do rozdziałów
 *  Pola:
 *    id: numer pytania
 *    chapter: 'r1'..'r6' – przypisanie tematyczne do rozdziału
 *    q: treść pytania
 *    opt: tablica opcji
 *    a: indeks poprawnej odpowiedzi lub tablica indeksów (wielokrotny wybór)
 *    exp: krótkie wyjaśnienie (opcjonalne)
 * ------------------------------------------------------*/
const examA = [
  // r1 – Podstawy testowania
  {id:1, chapter:"r1", q:"Która z poniższych odpowiedzi opisuje poprawny cel testów?", opt:["Udowodnienie, że w systemie nie ma nieusuniętych defektów.","Udowodnienie, że po wdrożeniu nie będzie awarii.","Obniżenie ryzyka i wzrost zaufania do jakości.","Sprawdzenie, czy nie pozostały nieprzetestowane kombinacje wejść."], a:2, exp:"Testowanie redukuje ryzyko i dostarcza informacji – nie dowodzi braku defektów."},
  {id:2, chapter:"r1", q:"Które stwierdzenie przyczynia się do sukcesu projektu?", opt:["Włączenie testerów w SDLC pomaga wykrywać defekty.","Nie przeszkadzamy programistom podczas kodowania.","Współpraca z użytkownikami podnosi raporty tylko na integracji/systemie.","Certyfikat gwarantuje lepsze testy."], a:0, exp:"Wczesne i szerokie włączenie testów zwiększa jakość i szybkość feedbacku."},
  {id:3, chapter:"r1", q:"Brak zmian w testach regresji od kilku iteracji… Jaka zasada?", opt:["Testy ulegają zużyciu.","Złudzenie braku defektów.","Defekty się kumulują.","Gruntowne testowanie jest niemożliwe."], a:0, exp:"Nieaktualizowane testy tracą skuteczność."},
  {id:7, chapter:"r1", q:"Najbardziej istotne umiejętności testera?", opt:["Wizja produktu i planowanie zespołu.","Wiedza domenowa, praca zespołowa, krytyczne myślenie.","Wiedza domenowa, wizja, krytyczne myślenie.","Praca zespołowa i planowanie pracy zespołu."], a:1},

  // r2 – Testowanie w cyklu wytwarzania (modele, Agile, ATDD, regresja, poziomy)
  {id:8, chapter:"r2", q:"Podejście 'cały zespół' a przedstawiciele biznesu", opt:["Biznes decyduje o automatyzacji.","Testerzy pomagają biznesowi w strategii testów.","Biznes nie jest objęty podejściem whole‑team.","Testerzy pomagają biznesowi tworzyć testy akceptacyjne."], a:3},
  {id:9, chapter:"r2", q:"Przypisanie czynności testowych do SDLC obowiązuje…", opt:["Tylko w sekwencyjnych.","Tylko w iteracyjnych.","Tylko w iteracyjnych i przyrostowych.","We wszystkich: sekwencyjnych, przyrostowych i iteracyjnych."], a:3},
  {id:10, chapter:"r2", q:"ATDD – najlepszy opis", opt:["Kryteria akceptacji zwykle Given/When/Then.","Testy ATDD tworzy się na etapie modułowym i są ukierunkowane na kod.","Testy z kryteriów akceptacji prowadzą implementację.","Testy z pożądanego zachowania, łatwe do zrozumienia."], a:2},
  {id:11, chapter:"r2", q:"Które NIE jest przykładem shift‑left?", opt:["Przegląd wymagań przed akceptacją.","Pisanie testu modułowego przed kodem.","Test wydajności modułu na etapie testów modułowych.","Pisanie skryptu testowego przed ustanowieniem zarządzania konfiguracją."], a:3},
  {id:13, chapter:"r2", q:"Dopasuj typy awarii do poziomów testów", opt:["1D, 2B, 3A, 4C","1D, 2B, 3C, 4A","1B, 2A, 3D, 4C","1C, 2B, 3A, 4D"], a:0},
  {id:14, chapter:"r2", q:"Które z poniższych testów są wykonywane jako testy regresji?", html:`<div class='muted' style='margin:6px 0'>Testujesz historyjkę użytkownika z KA1 ↔ PT1, KA2 ↔ PT2, KA3 ↔ PT3. Wykonano trzy przebiegi.</div>
    <table style='border-collapse:collapse;width:100%;font-size:14px'>
      <tr><th style='border:1px solid #ccc;padding:4px'></th><th style='border:1px solid #ccc;padding:4px'>Przebieg 1</th><th style='border:1px solid #ccc;padding:4px'>Przebieg 2</th><th style='border:1px solid #ccc;padding:4px'>Przebieg 3</th></tr>
      <tr><td style='border:1px solid #ccc;padding:4px'>PT1</td><td style='border:1px solid #ccc;padding:4px'>(1) Niezaliczony</td><td style='border:1px solid #ccc;padding:4px'>(4) Zaliczony</td><td style='border:1px solid #ccc;padding:4px'>(7) Zaliczony</td></tr>
      <tr><td style='border:1px solid #ccc;padding:4px'>PT2</td><td style='border:1px solid #ccc;padding:4px'>(2) Zaliczony</td><td style='border:1px solid #ccc;padding:4px'>(5) Niezaliczony</td><td style='border:1px solid #ccc;padding:4px'>(8) Zaliczony</td></tr>
      <tr><td style='border:1px solid #ccc;padding:4px'>PT3</td><td style='border:1px solid #ccc;padding:4px'>(3) Niezaliczony</td><td style='border:1px solid #ccc;padding:4px'>(6) Niezaliczony</td><td style='border:1px solid #ccc;padding:4px'>(9) Zaliczony</td></tr>
    </table>
    <div class='muted' style='margin-top:6px'>Testy powtarzane dopiero po informacji, że wszystkie defekty z poprzednich przebiegów usunięto i dostępna jest nowa wersja.</div>`, opt:["Tylko 4, 7, 8 i 9.","Tylko 5 i 7.","Tylko 4, 6, 8 i 9.","Tylko 5 i 6."], a:0},
  {id:16, chapter:"r2", q:"Korzyść z wczesnych i częstych informacji zwrotnych?", opt:["Usprawnienie procesu na przyszłość.","Wymuszenie priorytetów przez ryzyka.","Jedyny sposób mierzenia jakości zmian.","Unikanie nieporozumień wymagań."], a:3},
  {id:29, chapter:"r2", q:"ATDD dla historyjki redaktora – najlepszy przykład", opt:["Sprawdzenie zapisu dokumentu po redakcji przez redaktora.","Właściciel treści loguje się i aktualizuje treść.","Redaktor ustawia termin publikacji.","Redaktor zleca innemu redaktorowi aktualizację."], a:0},
  {id:30, chapter:"r2", q:"Wkład testerów w planowanie iteracji/wydań", opt:["Ustalają priorytety historyjek.","Skupiają się tylko na funkcjach.","Identyfikują i oceniają ryzyka dla historyjek.","Gwarantują jakość, projektując testy na starcie."], a:2},
  {id:34, chapter:"r2", q:"Kwadranty zwinne – przypisanie", opt:["1C, 2A, 3B, 4D","1D, 2A, 3C, 4B","1C, 2B, 3D, 4A","1D, 2B, 3C, 4A"], a:0},
  {id:36, chapter:"r2", q:"Artefakt pokazujący wykonaną i pozostałą pracę w iteracji", opt:["Kryteria akceptacji","Raport o defekcie","Raport sumaryczny","Wykres spalania"], a:3},

  // r3 – Testowanie statyczne (przeglądy)
  {id:15, chapter:"r3", q:"Korzyści testowania statycznego — które NIE?", opt:["Niższe koszty zarządzania defektami dzięki wykrywaniu późno.","Tańsze usuwanie defektów niż przy dynamicznym.","Wykrywanie defektów niewykrywalnych wyłącznie dynamicznie.","Wykrywanie luk i niespójności w wymaganiach."], a:0},
  {id:17, chapter:"r3", q:"Atrybuty przeglądów – który typ najpewniej?", opt:["Nieformalny","Przejrzenie","Przegląd techniczny","Inspekcja"], a:1},
  {id:18, chapter:"r3", q:"Co NIE wspiera sukcesu przeglądu?", opt:["Odpowiedni czas na przegląd.","Dzielenie dużych produktów na mniejsze.","Unikanie oznak znudzenia/irytacji/wrogości.","Obiektywne traktowanie wykrytych awarii."], a:2},

  // r4 – Analiza i projektowanie testów (techniki)
  {id:4, chapter:"r4", q:"Która czynność to analiza testów (płatności)?", opt:["Oszacowanie czasu 8 osobo‑dni.","Decyzja, by przetestować podział płatności.","Zastosowanie BVA do minimalnej kwoty.","Analiza rozbieżności i zgłoszenie defektu po teście karty."], a:1},
  {id:19, chapter:"r4", q:"Cechy technik opartych na doświadczeniu", opt:["Tworzone na podstawie szczegółów projektowych.","Pokrycie mierzone elementami testowanymi w interfejsach kodu.","Silnie bazują na wiedzy testera o systemie i domenie.","Identyfikują odchylenia od wymagań przypadkami."], a:2},
  {id:20, chapter:"r4", q:"Formularz mieszkań — ECP: minimalna liczba przypadków dla 100% klas?", opt:["3","4","5","6"], a:1},
  {id:21, chapter:"r4", q:"Jakie pokrycie wartości brzegowych (dwupunktowo) osiąga zestaw PT1–PT6?", html:`<div class='muted'>Ocena końcowa ustalana wg progów: 0–50 niedost., 51–60 dopuszczająca, 61–70 dostateczna, 71–80 dobra, 81–90 bardzo dobra, 91–100 celująca.</div>
    <table style='border-collapse:collapse;width:100%;font-size:14px;margin-top:6px'>
      <tr><th style='border:1px solid #ccc;padding:4px'>PT</th><th style='border:1px solid #ccc;padding:4px'>Wynik</th><th style='border:1px solid #ccc;padding:4px'>Ocena</th></tr>
      <tr><td style='border:1px solid #ccc;padding:4px'>PT1</td><td style='border:1px solid #ccc;padding:4px'>91</td><td style='border:1px solid #ccc;padding:4px'>celująca</td></tr>
      <tr><td style='border:1px solid #ccc;padding:4px'>PT2</td><td style='border:1px solid #ccc;padding:4px'>50</td><td style='border:1px solid #ccc;padding:4px'>niedostateczna</td></tr>
      <tr><td style='border:1px solid #ccc;padding:4px'>PT3</td><td style='border:1px solid #ccc;padding:4px'>81</td><td style='border:1px solid #ccc;padding:4px'>bardzo dobra</td></tr>
      <tr><td style='border:1px solid #ccc;padding:4px'>PT4</td><td style='border:1px solid #ccc;padding:4px'>60</td><td style='border:1px solid #ccc;padding:4px'>dopuszczająca</td></tr>
      <tr><td style='border:1px solid #ccc;padding:4px'>PT5</td><td style='border:1px solid #ccc;padding:4px'>70</td><td style='border:1px solid #ccc;padding:4px'>dostateczna</td></tr>
      <tr><td style='border:1px solid #ccc;padding:4px'>PT6</td><td style='border:1px solid #ccc;padding:4px'>80</td><td style='border:1px solid #ccc;padding:4px'>dobra</td></tr>
    </table>`, opt:["50%","60%","33,3%","100%"], a:1},
  {id:22, chapter:"r4", q:"Wypożyczalnia rowerów — która reguła jest niemożliwa?", html:`<div class='muted'>Uczestnik programu lojalnościowego: rabat 20%. Brak zwrotu w terminie: brak rabatu. 15‑te wypożyczenie: koszulka.</div>
    <table style='border-collapse:collapse;width:100%;font-size:14px;margin-top:6px'>
      <tr><th style='border:1px solid #ccc;padding:4px'>Warunki</th><th style='border:1px solid #ccc;padding:4px'>R1</th><th style='border:1px solid #ccc;padding:4px'>R2</th><th style='border:1px solid #ccc;padding:4px'>R3</th><th style='border:1px solid #ccc;padding:4px'>R4</th><th style='border:1px solid #ccc;padding:4px'>R5</th><th style='border:1px solid #ccc;padding:4px'>R6</th><th style='border:1px solid #ccc;padding:4px'>R7</th><th style='border:1px solid #ccc;padding:4px'>R8</th></tr>
      <tr><td style='border:1px solid #ccc;padding:4px'>Udział w programie</td><td style='border:1px solid #ccc;padding:4px'>P</td><td style='border:1px solid #ccc;padding:4px'>P</td><td style='border:1px solid #ccc;padding:4px'>P</td><td style='border:1px solid #ccc;padding:4px'>P</td><td style='border:1px solid #ccc;padding:4px'>F</td><td style='border:1px solid #ccc;padding:4px'>F</td><td style='border:1px solid #ccc;padding:4px'>F</td><td style='border:1px solid #ccc;padding:4px'>F</td></tr>
      <tr><td style='border:1px solid #ccc;padding:4px'>Zwrot w terminie</td><td style='border:1px solid #ccc;padding:4px'>P</td><td style='border:1px solid #ccc;padding:4px'>F</td><td style='border:1px solid #ccc;padding:4px'>P</td><td style='border:1px solid #ccc;padding:4px'>F</td><td style='border:1px solid #ccc;padding:4px'>P</td><td style='border:1px solid #ccc;padding:4px'>F</td><td style='border:1px solid #ccc;padding:4px'>F</td><td style='border:1px solid #ccc;padding:4px'>P</td></tr>
      <tr><td style='border:1px solid #ccc;padding:4px'>15. wypożyczenie</td><td style='border:1px solid #ccc;padding:4px'>F</td><td style='border:1px solid #ccc;padding:4px'>F</td><td style='border:1px solid #ccc;padding:4px'>P</td><td style='border:1px solid #ccc;padding:4px'>P</td><td style='border:1px solid #ccc;padding:4px'>F</td><td style='border:1px solid #ccc;padding:4px'>F</td><td style='border:1px solid #ccc;padding:4px'>P</td><td style='border:1px solid #ccc;padding:4px'>P</td></tr>
      <tr><td style='border:1px solid #ccc;padding:4px'><b>Akcje</b>: rabat 20%</td><td style='border:1px solid #ccc;padding:4px'></td><td style='border:1px solid #ccc;padding:4px'>X</td><td style='border:1px solid #ccc;padding:4px'></td><td style='border:1px solid #ccc;padding:4px'>X</td><td style='border:1px solid #ccc;padding:4px'></td><td style='border:1px solid #ccc;padding:4px'></td><td style='border:1px solid #ccc;padding:4px'></td><td style='border:1px solid #ccc;padding:4px'></td></tr>
      <tr><td style='border:1px solid #ccc;padding:4px'><b>Akcje</b>: koszulka</td><td style='border:1px solid #ccc;padding:4px'></td><td style='border:1px solid #ccc;padding:4px'>X</td><td style='border:1px solid #ccc;padding:4px'></td><td style='border:1px solid #ccc;padding:4px'>X</td><td style='border:1px solid #ccc;padding:4px'></td><td style='border:1px solid #ccc;padding:4px'></td><td style='border:1px solid #ccc;padding:4px'></td><td style='border:1px solid #ccc;padding:4px'>X</td></tr>
    </table>`, opt:["R4","R2","R6","R8"], a:3},
  {id:23, chapter:"r4", q:"Jaka jest minimalna liczba przypadków do pokrycia poprawnych przejść?", html:`<div class='muted' style='margin-bottom:6px'>System zaczyna w <b>INICJOWANIE</b>, kończy w <b>WYŁ</b>.</div>
    <svg viewBox='0 0 600 180' width='100%' height='180' style='background:#fff;border:1px solid #eee;border-radius:8px'>
      <defs><style>.n{font:12px sans-serif}</style></defs>
      <rect x='20' y='20' width='110' height='36' fill='#eef' stroke='#99c'/><text x='75' y='42' text-anchor='middle' class='n'>INICJOWANIE</text>
      <rect x='200' y='20' width='110' height='36' fill='#eef' stroke='#99c'/><text x='255' y='42' text-anchor='middle' class='n'>TRYB DEBUG</text>
      <rect x='380' y='20' width='110' height='36' fill='#eef' stroke='#99c'/><text x='435' y='42' text-anchor='middle' class='n'>WYŁ</text>
      <rect x='200' y='120' width='110' height='36' fill='#eef' stroke='#99c'/><text x='255' y='142' text-anchor='middle' class='n'>PRACA</text>
      <rect x='380' y='120' width='130' height='36' fill='#eef' stroke='#99c'/><text x='445' y='142' text-anchor='middle' class='n'>WSTRZYMANIE</text>
      <line x1='130' y1='38' x2='200' y2='38' stroke='#333'/><text x='165' y='30' class='n'>test</text>
      <line x1='310' y1='38' x2='380' y2='38' stroke='#333'/><text x='345' y='30' class='n'>gotowe</text>
      <line x1='75' y1='56' x2='255' y2='120' stroke='#333'/><text x='140' y='100' class='n'>uruchomienie</text>
      <line x1='310' y1='138' x2='380' y2='138' stroke='#333'/><text x='345' y='130' class='n'>pauza</text>
      <line x1='380' y1='138' x2='310' y2='138' stroke='#333'/><text x='345' y='160' class='n'>wznowienie</text>
      <line x1='255' y1='120' x2='255' y2='56' stroke='#333'/><text x='265' y='90' class='n'>błąd</text>
    </svg>`, opt:["4","2","7","3"], a:3},
  {id:24, chapter:"r4", q:"100% pokrycia instrukcji oznacza…", opt:["Każda instrukcja zawierająca defekt została wykonana.","Dowolny większy zestaw też osiągnie 100% instrukcji.","Każda ścieżka musiała być wykonana.","Każda instrukcja została wykonana co najmniej raz."], a:3},
  {id:25, chapter:"r4", q:"Które stwierdzenie o białej skrzynce NIE jest prawdziwe?", opt:["Uwzględnia całą implementację.","Metryki pokrycia wskazują dodatkowe testy.","Można stosować w testowaniu statycznym.","Pozwala rozpoznać luki w implementacji wymagań."], a:2},
  {id:26, chapter:"r4", q:"Koncepcja zgadywania błędów — najlepszy opis", opt:["Wiedza o typowych defektach i błędach programistów.","Własne doświadczenie programistyczne.","Wyobrażenie użytkownika i jego pomyłek.","Szybka próba wytwarzania oprogramowania, by odtworzyć błędy."], a:0},
  {id:27, chapter:"r4", q:"Brak pełnych wymagań, potrzeba wstępnych wyników — jaka technika?", opt:["Lista kontrolna","Zgadywanie błędów","Eksploracyjne","Testowanie gałęzi"], a:2},
  {id:28, chapter:"r4", q:"Jak udokumentować kryteria akceptacji?", opt:["Retrospektywa potrzeb interesariuszy.","Warunek w Given/When/Then.","Słowne przekazanie informacji.","Ryzyka w planie testów dla danej historyjki."], a:1},

  // r5 – Zarządzanie testami (kryteria, estymacje, priorytety, ryzyko, CM, defekty)
  {id:5, chapter:"r5", q:"Czynniki istotnie wpływające na podejście do testów?", opt:["SDLC i liczba defektów z poprzednich projektów.","SDLC, ryzyka produktowe, wymogi formalnych testów białoskrzynkowych.","Liczba defektów wcześniej, wymogi białoskrzynkowe, konfiguracja środowiska.","Ryzyka produktowe i konfiguracja środowiska."], a:1},
  {id:6, chapter:"r5", q:"Wskaż DWA zadania głównie testerskie", opt:["Konfigurowanie środowiska testowego.","Prowadzenie backlogu produktu.","Projektowanie rozwiązań dla nowych wymagań.","Tworzenie planu testów.","Analizowanie podstawy testów."], a:[0,4]},
  {id:12, chapter:"r5", q:"Argument za retrospektywami po każdym cyklu release", opt:["Popularne – klienci zadowoleni.","Oszczędności, bo brak natychmiastowej informacji zwrotnej.","Analiza słabości → lista działań do ciągłego doskonalenia.","Realizują 5 wartości (np. odwaga, szacunek)."], a:2},
  {id:31, chapter:"r5", q:"Które DWIE stanowią kryteria wyjścia dla testowania systemu?", opt:["Gotowość środowiska","Możliwość zalogowania przez testera","Osiągnięcie szacowanej gęstości defektów","Przekształcenie wymagań do G/W/T","Zautomatyzowanie testów regresji"], a:[2,4]},
  {id:32, chapter:"r5", q:"Estymacja trójpunktowa: a=2, m=11, b=14 — wynik?", opt:["9","14","11","10"], a:3},
  {id:33, chapter:"r5", q:"Który z poniższych przypadków powinien zostać wykonany jako trzeci?", html:`<table style='border-collapse:collapse;width:100%;font-size:14px'>
      <tr><th style='border:1px solid #ccc;padding:4px'>Numer</th><th style='border:1px solid #ccc;padding:4px'>Warunek</th><th style='border:1px solid #ccc;padding:4px'>Priorytet</th><th style='border:1px solid #ccc;padding:4px'>Zależność</th></tr>
      <tr><td style='border:1px solid #ccc;padding:4px'>PT 001</td><td style='border:1px solid #ccc;padding:4px'>Wybór rodzaju kuchni</td><td style='border:1px solid #ccc;padding:4px'>3</td><td style='border:1px solid #ccc;padding:4px'>—</td></tr>
      <tr><td style='border:1px solid #ccc;padding:4px'>PT 002</td><td style='border:1px solid #ccc;padding:4px'>Wybór restauracji</td><td style='border:1px solid #ccc;padding:4px'>2</td><td style='border:1px solid #ccc;padding:4px'>PT 001</td></tr>
      <tr><td style='border:1px solid #ccc;padding:4px'>PT 003</td><td style='border:1px solid #ccc;padding:4px'>Uzyskanie wskazówek dojazdu</td><td style='border:1px solid #ccc;padding:4px'>1</td><td style='border:1px solid #ccc;padding:4px'>PT 002</td></tr>
      <tr><td style='border:1px solid #ccc;padding:4px'>PT 004</td><td style='border:1px solid #ccc;padding:4px'>Zatelefonowanie do restauracji</td><td style='border:1px solid #ccc;padding:4px'>2</td><td style='border:1px solid #ccc;padding:4px'>PT 002</td></tr>
      <tr><td style='border:1px solid #ccc;padding:4px'>PT 005</td><td style='border:1px solid #ccc;padding:4px'>Dokonanie rezerwacji</td><td style='border:1px solid #ccc;padding:4px'>3</td><td style='border:1px solid #ccc;padding:4px'>PT 002</td></tr>
    </table>`, opt:["PT 003","PT 005","PT 002","PT 001"], a:0},
  {id:35, chapter:"r5", q:"Ryzyko: długi czas odpowiedzi raportu; reakcje: testy wydajności + alfa/beta — to…", opt:["Akceptacja","Plan awaryjny","Łagodzenie","Przeniesienie"], a:2},
  {id:37, chapter:"r5", q:"Nowa wersja skryptu testu — jaki proces to rejestruje?", opt:["Śledzenie powiązań","Testowanie pielęgnacyjne","Zarządzanie konfiguracją","Inżynieria wymagań"], a:2},
  {id:38, chapter:"r5", q:"Raport o defekcie – czego brakuje?", opt:["Oczekiwany i rzeczywisty rezultat.","Odwołania i status defektu.","Środowisko testowe i element testowy.","Priorytet i krytyczność."], a:2},
  {id:39, chapter:"r5", q:"Narzędzie do przygotowania danych testowych – w której czynności?", opt:["Monitorowanie i nadzór","Analiza i projektowanie","Implementacja i wykonywanie","Ukończenie testów"], a:2},

  // r6 – Narzędzia testowe
  {id:40, chapter:"r6", q:"Ryzyko związane z automatyzacją testów?", opt:["Automatyzacja wprowadzi nieznane regresje na produkcji.","Nakłady na utrzymanie testaliów mogą być niewystarczające.","Narzędzia i testalia mogą nie cieszyć się zaufaniem.","Automatyzacja skraca czas na testy manualne."], a:2}
];

// Pytania dodatkowe A1–A26 (przypisane tematycznie do rozdziałów)
examA.push(
  // r1 — Podstawy testowania
  {id:"41", chapter:"r1", q:"Twoim zadaniem jest przeanalizowanie i usunięcie przyczyn awarii w nowym systemie. Którą czynność wykonujesz?", opt:["Debugowanie","Testowanie oprogramowania","Pozyskiwanie wymagań","Zarządzanie defektami"], a:0, exp:"Debugowanie = analiza przyczyny awarii i poprawka; po niej test potwierdzający (i regresja)."},
  {id:"42", chapter:"r1", q:"Dział testowania bywa nazywany działem zapewnienia jakości. Czy to poprawne?", opt:["Tak – to ten sam proces","Tak – można używać zamiennie","Nie – testowanie to szerszy proces niż zapewnienie jakości","Nie – QA dotyczy procesów jakości, testowanie wykazuje zdatność i defekty"], a:3, exp:"QA skupia się na procesach; testowanie ocenia produkt i ujawnia defekty."},
  {id:"43", chapter:"r1", q:"Nieprawidłowo zakodowana logika górnej wartości brzegowej to…", opt:["Podstawowa przyczyna","Awaria","Pomyłka","Defekt"], a:3, exp:"Błędny kod = defekt; awaria to objaw; pomyłka to błąd ludzki; przyczyna jest źródłem defektu."},
  {id:"A1", chapter:"r1", q:"Twoim zadaniem jest przeanalizowanie i usunięcie przyczyn awarii w nowym systemie. Którą czynność wykonujesz?", opt:["Debugowanie","Testowanie oprogramowania","Pozyskiwanie wymagań","Zarządzanie defektami"], a:0, exp:"Debugowanie polega na analizie przyczyny awarii i wprowadzeniu poprawki, po czym wykonuje się test potwierdzający (i regresję)."},
  {id:"A2", chapter:"r1", q:"Dział testowania bywa nazywany działem zapewnienia jakości. Czy to poprawne?", opt:["Tak – to ten sam proces","Tak – można używać zamiennie","Nie – testowanie to szerszy proces niż zapewnienie jakości","Nie – QA dotyczy procesów jakości, testowanie wykazuje zdatność i defekty"], a:3, exp:"QA skupia się na procesach jakości (zapewnienie), a testowanie ocenia produkt i ujawnia defekty – to nie są synonimy."},
  {id:"A3", chapter:"r1", q:"Nieprawidłowo zakodowana logika górnej wartości brzegowej to…", opt:["Podstawowa przyczyna","Awaria","Pomyłka","Defekt"], a:3, exp:"Błędny kod to defekt; awaria to widoczny objaw; pomyłka to błąd ludzki prowadzący do defektu; przyczyna jest źródłem defektu."},
  {id:"A5", chapter:"r1", q:"Który przykład NAJLEPIEJ pokazuje, jak śledzenie powiązań pomaga w testowaniu?", opt:["Analiza wpływu zmiany informuje o ukończeniu testów","Powiązania TC↔wyniki dają poziom ryzyka rezydualnego","Analiza wpływu zmiany pomaga dobrać testy regresji","Powiązania podstawa/element/TC ułatwiają dobór danych do pokrycia"], a:2, exp:"Traceability umożliwia wybór właściwych testów regresji po zmianach poprzez analizę powiązań."},
  {id:"A6", chapter:"r1", q:"Korzyść z niezależności testowania?", opt:["Można przenieść odpowiedzialność za jakość na zespół testowy","Zespół zewnętrzny nie ulega presji terminów","Niezależni testerzy pracują bez komunikacji z dev i tylko raportują defekty","Niezależni testerzy mogą zakwestionować założenia i interpretacje programisty"], a:3, exp:"Niezależna perspektywa pozwala kwestionować założenia autora i wykrywać niejednoznaczności/defekty wcześniej."},

  // r2 — Testowanie w cyklu wytwarzania
  {id:"A7", chapter:"r2", q:"W modelu V które aktywności MOŻNA wykonać wcześnie? (DWIE)", opt:["Testowanie dynamiczne","Testowanie statyczne","Planowanie testów","Wykonywanie testów akceptacyjnych","Testowanie pielęgnowalności"], a:[1,2], exp:"W V‑modelu wcześnie realizuje się planowanie i testy statyczne; wykonanie testów dynamicznych następuje później."},
  {id:"A8", chapter:"r2", q:"Które stwierdzenia opisują zalety DevOps?", opt:["Przyspieszenie wprowadzania produktów","Więcej powtarzalnych testów manualnych","Stała dostępność wykonywalnego oprogramowania","Mniej testów regresji po refaktoryzacji","Niskie koszty frameworków testów automatycznych dzięki automatyzacji całego procesu"], a:2, exp:"Główne korzyści: szybsze dostarczanie (i) oraz ciągła gotowość (iii); odpowiedź jednokrotna: i oraz iii → c."},
  {id:"A9", chapter:"r2", q:"Wymaganie: czas przetworzenia <10 s w 95% przypadków. Jaki typ testów?", opt:["Funkcjonalne","Niefunkcjonalne (wydajność)","Funkcjonalne (UI)","Strukturalne"], a:1, exp:"Mierzymy czas i SLA – to testy niefunkcjonalne (wydajnościowe)."},
  {id:"A10", chapter:"r2", q:"Test migracji danych przy wycofaniu systemu – w ramach jakiego typu testów?", opt:["Testowanie pielęgnacyjne","Testowanie regresji","Testowanie modułowe","Testowanie integracyjne"], a:0, exp:"Migracja przy wycofaniu/system replacement to typowe zadanie w testowaniu pielęgnacyjnym (maintenance)."},
  {id:"A18", chapter:"r2", q:"Wspólne pisanie historyjek użytkownika – najlepszy opis", opt:["PO akceptuje historie stworzone przez dev+QA","Historie tworzą wspólnie biznes, programiści i testerzy","Historie tworzy biznes, a dev/test je weryfikują","Historie powinny spełniać INVEST"], a:1, exp:"W podejściu zinnym historyjki powstają kolaboracyjnie: biznes + dev + test (three amigos)."},

  // r3 — Testowanie statyczne
  {id:"A11", chapter:"r3", q:"Które produkty pracy można objąć przeglądem?", opt:["Wymagania biznesowe","Harmonogram","Budżet testów","Kod wykonywalny innych firm","Historyjki i ich kryteria akceptacji"], a:2, exp:"Przeglądy obejmują m.in. wymagania, harmonogram, budżet testów oraz historyjki z kryteriami (i, ii, iii, v) → opcja C."},
  {id:"A12", chapter:"r3", q:"Które stwierdzenia o testowaniu statycznym są prawdziwe?", opt:["Łatwiej identyfikuje nieprawidłowe zewnętrzne zachowania","Łatwiej wykrywa odstępstwa od standardu kodowania","Umożliwia wykrycie awarii podczas uruchamiania","Celem jest jak najwcześniejsze wykrycie defektów","Łatwiej znaleźć i skorygować braki pokrycia krytycznych wymagań bezpieczeństwa"], a:3, exp:"Dla statycznego prawdą są ii i iv oraz v → odpowiedź D."},
  {id:"A13", chapter:"r3", q:"Które stwierdzenie o przeglądach formalnych jest PRAWDZIWE?", opt:["Niektóre przeglądy nie wymagają więcej niż jednej roli","Proces przeglądu składa się z kilku czynności","Dokument nie jest przekazywany przed spotkaniem","Defekty z przeglądu się nie zgłasza"], a:1, exp:"Formalny proces przeglądu ma zdefiniowane kroki (planowanie, przygotowanie, spotkanie, rework, follow‑up)."},
  {id:"A14", chapter:"r3", q:"Jakie zadanie może wykonywać kierownictwo podczas przeglądu formalnego?", opt:["Przyjęcie ogólnej odpowiedzialności za przegląd","Decydowanie, co ma być przedmiotem przeglądu","Moderowanie spotkania i mediacja","Protokołowanie"], a:1, exp:"To kierownictwo decyduje o zakresie/przedmiocie przeglądu; moderacja i protokołowanie są innymi rolami."},

  // r4 — Analiza i projektowanie testów
  {id:"A4", chapter:"r4", q:"Karta opisu testu (obiekt, dane, wykrywane defekty). W której czynności powstała?", opt:["Planowanie testów","Monitorowanie i nadzór","Analiza testów","Projektowanie testów"], a:3, exp:"Karta/procedura testu powstaje podczas projektowania testów – po analizie warunków."},
  {id:"A15", chapter:"r4", q:"Sterowanie temperaturą: BVA 3‑punktowa dla T=12. Minimalny zbiór wejść?", opt:["11, 12, 13","10, 12, 14","10, 11, 12, 13, 14","10, 11, 13, 14"], a:0, exp:"BVA 3‑punktowa testuje wartość brzegową i sąsiadujące: 11, 12, 13."},
  {id:"A16", chapter:"r4", q:"Które stwierdzenie o testowaniu gałęzi jest poprawne?", opt:["Przy gałęziach bezwarunkowych 100% gałęzi bez testów","Sprawdzenie wszystkich gałęzi bezwarunkowych daje 100% pokrycia","100% instrukcji ⇒ 100% gałęzi","100% gałęzi ⇒ sprawdzono wszystkie wyniki decyzji w każdej instrukcji decyzyjnej"], a:3, exp:"Pokrycie gałęzi 100% oznacza przejście wszystkich wyników decyzji w każdej instrukcji decyzyjnej."},
  {id:"A17", chapter:"r4", q:"Ocena ekranów wg ogólnej listy dobrych praktyk UI – to…", opt:["Testowanie czarnoskrzynkowe","Testowanie eksploracyjne","Testowanie w oparciu o listę kontrolną","Zgadywanie błędów"], a:2, exp:"Lista kontrolna (checklist‑based) to technika oparta na doświadczeniu, z gotowym zbiorem heurystyk."},

  // r5 — Zarządzanie testami
  {id:"A19", chapter:"r5", q:"W której części planu testów: wymagane 100% pokrycia gałęzi dla krytycznych modułów?", opt:["Wymiana informacji","Rejestr ryzyk","Kontekst testowania","Podejście do testowania"], a:3, exp:"Wybór kryterium pokrycia i poziomów testów to element podejścia do testowania."},
  {id:"A20", chapter:"r5", q:"Poker planistyczny: po 3. rundzie najwięcej głosów ma 13. Co dalej?", html:`<table style='border-collapse:collapse;width:100%;font-size:14px'>
      <tr><th style='border:1px solid #ccc;padding:4px'>Runda</th><th style='border:1px solid #ccc;padding:4px' colspan='7'>Oszacowania</th></tr>
      <tr><td style='border:1px solid #ccc;padding:4px'>Runda 1</td><td style='border:1px solid #ccc;padding:4px'>21</td><td style='border:1px solid #ccc;padding:4px'>2</td><td style='border:1px solid #ccc;padding:4px'>5</td><td style='border:1px solid #ccc;padding:4px'>34</td><td style='border:1px solid #ccc;padding:4px'>13</td><td style='border:1px solid #ccc;padding:4px'>8</td><td style='border:1px solid #ccc;padding:4px'>2</td></tr>
      <tr><td style='border:1px solid #ccc;padding:4px'>Runda 2</td><td style='border:1px solid #ccc;padding:4px'>13</td><td style='border:1px solid #ccc;padding:4px'>8</td><td style='border:1px solid #ccc;padding:4px'>8</td><td style='border:1px solid #ccc;padding:4px'>34</td><td style='border:1px solid #ccc;padding:4px'>13</td><td style='border:1px solid #ccc;padding:4px'>8</td><td style='border:1px solid #ccc;padding:4px'>5</td></tr>
      <tr><td style='border:1px solid #ccc;padding:4px'>Runda 3</td><td style='border:1px solid #ccc;padding:4px'>13</td><td style='border:1px solid #ccc;padding:4px'>8</td><td style='border:1px solid #ccc;padding:4px'>13</td><td style='border:1px solid #ccc;padding:4px'>13</td><td style='border:1px solid #ccc;padding:4px'>13</td><td style='border:1px solid #ccc;padding:4px'>13</td><td style='border:1px solid #ccc;padding:4px'>8</td></tr>
    </table>`, opt:["PO podejmuje decyzję","Przyjąć 13 jako ostateczne oszacowanie","Konsensus osiągnięty","Usunąć funkcjonalność z wydania"], a:1, exp:"Reguła zespołu: jeśli różnice są małe, przyjmij wartość z największą liczbą głosów – 13."},
  {id:"A21", chapter:"r5", q:"Piramida testów – które stwierdzenie jest prawdziwe?", opt:["Więcej testów na niższych poziomach","Każdy test niskopoziomowy sprawdza większą część funkcjonalności","Opisuje rozkład typów testów w SDLC","Nie wpływa na budowę testów automatycznych"], a:0, exp:"Piramida promuje większy wolumen testów na niższych poziomach (tańsze, szybsze, stabilniejsze)."},
  {id:"A22", chapter:"r5", q:"Wpływ ryzyka jest bardzo duży. Co z prawdopodobieństwem?", opt:["Też bardzo duże","Bardzo małe","Nie można nic powiedzieć – są niezależne","Nieistotne przy dużym wpływie"], a:2, exp:"Wpływ i prawdopodobieństwo są osobnymi wymiarami oceny ryzyka – wysokie jedno nie determinuje drugiego."},
  {id:"A23", chapter:"r5", q:"Które to ryzyka projektowe?", opt:["i oraz iv","iv oraz v","i oraz iii","ii oraz v"], a:0, exp:"Ryzyka projektowe dotyczą zarządzania projektem (zasoby, harmonogram, oczekiwania) – tutaj i oraz iv."},
  {id:"A24", chapter:"r5", q:"Jak analiza ryzyka produktowego wpływa na staranność i zakres?", opt:["Codzienny monitoring ryzyk do decyzji o release","Zidentyfikowano ryzyko braku obsługi OSS DB → integracja","Ilościowa ocena łącznego ryzyka rezydualnego przed testami","Wysokie ryzyko wydajności → szczegółowe testy wydajności wcześnie"], a:3, exp:"Wysokie ryzyko wydajności uzasadnia wcześniejsze i dokładniejsze testy wydajnościowe."},
  {id:"A25", chapter:"r5", q:"Wskaż DWIE metryki poziomu jakości przedmiotu testów", opt:["Liczba defektów wykrytych w testach systemowych","Nakład projektowania/ liczba TC","Liczba wykonanych procedur testowych","Gęstość defektów (defekty/rozmiar)","Czas usunięcia defektu"], a:[0,3], exp:"Typowe metryki jakości produktu: liczba defektów (np. z systemu) oraz gęstość defektów."},
  {id:"A26", chapter:"r5", q:"Która informacja w raporcie postępu jest NAJMNIEJ przydatna dla biznesu?", opt:["Przeszkody w testowaniu","Uzyskane pokrycie gałęzi","Postęp testów","Nowe ryzyka w cyklu testowym"], a:1, exp:"Pokrycie gałęzi to techniczna metryka niskopoziomowa; biznes bardziej interesuje postęp, ryzyka i przeszkody."}
);

/** -------------------------------------------------------
 *  PROSTA „PLATFORMA”
 * ------------------------------------------------------*/
const $$ = (sel, root=document) => root.querySelector(sel);
const $all = (sel, root=document) => Array.from(root.querySelectorAll(sel));

const state = {
  current: 0,
  page: 0,
  flash: {side:"q", i:0},
  quizAnswers: {},
  currentQuestionIndex: 0, // Indeks aktualnego pytania na stronie
  results: JSON.parse(localStorage.getItem("istqb_results")||"{}")
};

// System linkowania pytań - automatyczne dopasowywanie pytań do stron
const questionMatcher = {
  // Słowa kluczowe dla różnych tematów
  keywords: {
    "podstawy_testowania": ["cel testów", "weryfikacja", "walidacja", "defekty", "awarie", "zasady testowania", "debugowanie", "testowanie statyczne", "testowanie dynamiczne"],
    "sdlc": ["SDLC", "cykl wytwarzania", "modele", "iteracyjny", "przyrostowy", "agile", "ATDD", "TDD", "BDD", "DevOps", "shift left", "retrospektywa"],
    "poziomy_testow": ["poziom testów", "modułowe", "integracja", "systemowe", "akceptacyjne", "testowanie funkcjonalne", "testowanie niefunkcjonalne"],
    "techniki_staticzne": ["testowanie statyczne", "przegląd", "inspekcja", "przejrzenie", "analiza statyczna", "moderator", "protokolant"],
    "techniki_projektowania": ["techniki projektowania", "czarnoskrzynkowe", "białoskrzynkowe", "ECP", "BVA", "state transition", "pokrycie", "gałęzie", "instrukcje"],
    "zarzadzanie_testami": ["plan testów", "zarządzanie", "monitorowanie", "estymacja", "ryzyko", "niezależność", "śledzenie powiązań", "testalia"],
    "narzedzia": ["narzędzia", "automatyzacja", "CI/CD", "framework", "utrzymanie", "testy regresji", "dane testowe"]
  },
  
  // Mapowanie pytań do tematów na podstawie treści
  mapQuestionToTopics(question) {
    const topics = [];
    const qText = (question.q || "").toLowerCase();
    const expText = (question.exp || "").toLowerCase();
    const fullText = qText + " " + expText;
    
    for (const [topic, keywords] of Object.entries(this.keywords)) {
      if (keywords.some(keyword => fullText.includes(keyword.toLowerCase()))) {
        topics.push(topic);
      }
    }
    return topics;
  },
  
  // Mapowanie stron do tematów na podstawie treści strony
  mapPageToTopics(page) {
    const topics = [];
    const pageText = (page.html || "").toLowerCase();
    const titleText = (page.title || "").toLowerCase();
    const fullText = pageText + " " + titleText;
    
    for (const [topic, keywords] of Object.entries(this.keywords)) {
      if (keywords.some(keyword => fullText.includes(keyword.toLowerCase()))) {
        topics.push(topic);
      }
    }
    return topics;
  },
  
  // Znajdowanie pytań pasujących do strony
  findQuestionsForPage(page, allQuestions) {
    const pageTopics = this.mapPageToTopics(page);
    const matchingQuestions = [];
    
    for (const question of allQuestions) {
      const questionTopics = this.mapQuestionToTopics(question);
      
      // Sprawdź czy pytanie ma wspólne tematy ze stroną
      const commonTopics = pageTopics.filter(topic => questionTopics.includes(topic));
      if (commonTopics.length > 0) {
        matchingQuestions.push({
          question: question,
          relevance: commonTopics.length,
          topics: commonTopics
        });
      }
    }
    
    // Sortuj według trafności (więcej wspólnych tematów = wyższa trafność)
    return matchingQuestions.sort((a, b) => b.relevance - a.relevance);
  }
};

// Pytania egzaminacyjne - skopiowane z egzamin_quiz_full.html
const examQuestions = [
  {q:"Która z poniższych odpowiedzi opisuje poprawny cel testów?", opt:["Udowodnienie, że w systemie podlegającym testowaniu nie występują żadne nieusunięte defekty.","Udowodnienie, że po wprowadzeniu systemu do eksploatacji nie będą występowały żadne awarie.","Obniżenie poziomu ryzyka związanego z przedmiotem testów i zwiększenie zaufania do jego jakości.","Sprawdzenie, czy nie pozostały żadne nieprzetestowane kombinacje danych wejściowych."], a:2, exp:"Testy dostarczają informacji, redukują ryzyko i budują zaufanie; nie dowodzą braku defektów."},
  {q:"Które z poniższych stwierdzeń zawiera przykład czynności testowych, które przyczyniają się do powodzenia projektu?", opt:["Zaangażowanie testerów w różne działania podejmowane w ramach cyklu wytwarzania oprogramowania (SDLC) pomaga wykryć defekty w produktach pracy.","Testerzy starają się nie przeszkadzać programistom na etapie pisania kodu, aby umożliwić im tworzenie kodu o wyższej jakości.","Współpraca testerów z użytkownikami pozwala podnieść jakość raportów o defektach podczas testowania integracji modułów i testowania systemowego.","Certyfikowani testerzy projektują znacznie lepsze przypadki testowe niż testerzy, którzy nie posiadają certyfikatu."], a:0, exp:"Wczesne i szerokie włączenie testów w SDLC zwiększa jakość i szybkość informacji zwrotnej."},
  {q:"Rozpoczynasz pracę jako tester w zespole opracowującym nowy system metodą przyrostową. Zauważasz, że od kilku iteracji nie wprowadzono żadnych zmian w przypadkach testowych używanych do testowania regresji, a także nie zidentyfikowano żadnych nowych defektów związanych z regresją. Twój kierownik jest zadowolony — w przeciwieństwie do ciebie. Która zasada testowania uzasadnia twój sceptycyzm?", opt:["Testy ulegają zużyciu.","Przekonanie o braku defektów jest błędem.","Defekty mogą się kumulować.","Testowanie gruntowne jest niemożliwe."], a:0, exp:"Nieaktualizowane testy regresji tracą skuteczność (zużywają się)."},
  {q:"Pracujesz w zespole, który tworzy aplikację mobilną do zamawiania posiłków. Zespół postanowił, że w bieżącej iteracji ma zostać zaimplementowana funkcjonalność obsługi płatności. Która z wymienionych czynności jest elementem analizy testów?", opt:["Oszacowanie, że testowanie integracji z usługą płatniczą potrwa 8 osobodni.","Podjęcie decyzji, że zespół powinien przetestować, czy istnieje możliwość prawidłowego podziału płatności między kilku użytkowników.","Zastosowanie metody analizy wartości brzegowych w celu opracowania danych testowych na potrzeby przypadków testowych, które sprawdzają prawidłowość przetwarzania płatności w minimalnej dozwolonej kwocie.","Przeanalizowanie rozbieżności między rzeczywistym a oczekiwanym rezultatem po wykonaniu przypadku testowego sprawdzającego przetwarzanie płatności kartą kredytową, a następnie zgłoszenie defektu."], a:1, exp:"Analiza testów identyfikuje co testować (warunki), projektowanie określa dane (np. BVA)."},
  {q:"Które z poniższych czynników (i–v) mają ISTOTNY wpływ na podejście do testów? i. Cykl życia wytwarzania oprogramowania (SDLC). ii. Liczba defektów wykrytych w poprzednich projektach. iii. Zidentyfikowane ryzyka produktowe. iv. Nowe wymagania wynikające z przepisów wymuszające formalne testowanie białoskrzynkowe. v. Konfiguracja środowiska testowego.", opt:["i oraz ii mają istotny wpływ.","i, iii oraz iv mają istotny wpływ.","ii, iv oraz v mają istotny wpływ.","iii oraz v mają istotny wpływ."], a:1, exp:"Kontekst SDLC, ryzyka produktowe oraz wymogi (np. regulacyjne) kształtują podejście."},
  {q:"Wskaż DWA z wymienionych poniżej zadań, które są przypisane GŁÓWNIE do roli związanej z testowaniem.", opt:["Konfigurowanie środowiska testowego.","Prowadzenie backlogu produktu.","Projektowanie rozwiązań dla nowych wymagań.","Tworzenie planu testów.","Analizowanie podstawy testów."], a:[0,4], exp:"Głównie testerskie: analizowanie podstawy testów oraz (w wielu organizacjach) konfiguracja środowiska testowego."},
  {q:"Które z poniższych umiejętności (i–v) są NAJBARDZIEJ ISTOTNYMI umiejętnościami w pracy testera? i. Posiadanie wiedzy merytorycznej. ii. Tworzenie wizji produktu. iii. Umiejętność sprawnej pracy w zespole. iv. Planowanie i organizowanie pracy zespołu. v. Krytyczne myślenie.", opt:["Umiejętności ii oraz iv.","Umiejętności i, iii oraz v.","Umiejętności i, ii oraz v.","Umiejętności iii oraz iv."], a:1, exp:"Esencja: domena, współpraca i krytyczne myślenie."},
  {q:"W jaki sposób podejście 'cały zespół' uwidacznia się w kontaktach testerów z przedstawicielami jednostek biznesowych?", opt:["Przedstawiciele jednostek biznesowych decydują o podejściu do automatyzacji testów.","Testerzy pomagają przedstawicielom jednostek biznesowych w określaniu strategii testów.","Przedstawiciele jednostek biznesowych nie są objęci podejściem opartym na zaangażowaniu całego zespołu (podejście 'cały zespół').","Testerzy pomagają przedstawicielom jednostek biznesowych w tworzeniu odpowiednich testów akceptacyjnych."], a:3, exp:"W whole‑team testerzy współtworzą z biznesem testy akceptacyjne."},
  {q:"Zastanów się nad następującą zasadą: 'Do każdej czynności związanej z wytwarzaniem oprogramowania (SDLC) powinna być przypisana odpowiadająca jej czynność testowa'. W których modelach cyklu wytwarzania oprogramowania (SDLC) obowiązuje ta zasada?", opt:["Tylko w sekwencyjnych modelach wytwarzania oprogramowania.","Tylko w iteracyjnych modelach wytwarzania oprogramowania.","Tylko w iteracyjnych i przyrostowych modelach wytwarzania oprogramowania.","W sekwencyjnych, przyrostowych i iteracyjnych modelach wytwarzania oprogramowania."], a:3, exp:"Dotyczy wszystkich modeli SDLC."},
  {q:"Które z poniższych stwierdzeń NAJLEPIEJ opisuje wytwarzanie sterowane testami akceptacyjnymi (ATDD)?", opt:["W modelu ATDD kryteria akceptacji są zwykle tworzone w formacie Given/When/Then (Mając/Kiedy/Wtedy).","W modelu ATDD przypadki testowe są zwykle tworzone na etapie testowania modułowego i są ukierunkowane na kod.","W modelu ATDD testy są tworzone na podstawie kryteriów akceptacji i określają sposób tworzenia związanego z nimi oprogramowania.","W modelu ATDD testy są tworzone na podstawie pożądanego zachowania oprogramowania, co ułatwia członkom zespołu ich zrozumienie."], a:2, exp:"ATDD: zaczynamy od kryteriów akceptacji, które prowadzą implementację."},
  {q:"Twoim zadaniem jest przeanalizowanie i usunięcie przyczyn awarii w nowym systemie, który ma zostać przekazany do eksploatacji. Którą z wymienionych czynności wykonujesz?", opt:["Debugowanie.","Testowanie oprogramowania.","Pozyskiwanie wymagań.","Zarządzanie defektami."], a:0, exp:"Debugowanie = diagnoza przyczyny awarii i wprowadzenie poprawki (potem test potwierdzający i regresja)."},
  {q:"W wielu organizacjach, które wytwarzają oprogramowanie, dział odpowiedzialny za testowanie jest nazywany działem zapewnienia jakości. Czy to zdanie jest poprawne, a jeśli nie, to dlaczego?", opt:["Zdanie jest poprawne. Testowanie i zapewnienie jakości to dwa różne określenia na ten sam proces.","Zdanie jest poprawne. Określenia te mogą być używane wymiennie, ponieważ działania wykonywane w ramach testowania i działania wykonywane w ramach zapewnienia jakości koncentrują się na tych samych problemach związanych z jakością.","Zdanie jest niepoprawne. Testowanie jest szerszym procesem, który obejmuje wszystkie działania związane z jakością, a zapewnienie jakości koncentruje się na procesach związanych z jakością.","Zdanie jest niepoprawne. Zapewnienie jakości koncentruje się na procesach związanych z jakością, a testowanie — na wykazaniu, że dany moduł lub system jest zdatny do użytku zgodnie z przeznaczeniem, oraz na wykryciu ewentualnych defektów."], a:3, exp:"QA koncentruje się na procesach jakości; testowanie ocenia produkt i ujawnia defekty."},
  {q:"Telefon dzwoniący w sąsiednim pomieszczeniu chwilowo rozproszył programistę, przez co niewłaściwie zaprogramował on logikę sprawdzającą górną wartość brzegową jednej ze zmiennych wejściowych. Później, w trakcie testowania systemowego, tester zauważył, że system akceptuje nieprawidłowe wartości wejściowe wpisywane w polu wprowadzania danych. Nieprawidłowo zakodowana logika sprawdzania górnej wartości brzegowej to:", opt:["Podstawowa przyczyna.","Awaria.","Pomyłka.","Defekt."], a:3, exp:"Błędny kod = defekt; awaria to objaw; pomyłka to błąd ludzki prowadzący do defektu."}
];

// Funkcja do ładowania pytań (teraz nie jest potrzebna, ale zostawiamy dla kompatybilności)
async function loadExamQuestions() {
  console.log(`Załadowano ${examQuestions.length} pytań egzaminacyjnych`);
}

// Funkcja do pobierania pytań dla konkretnej strony
function getQuestionsForPage(page) {
  if (examQuestions.length === 0) {
    // Fallback do pytań z poziomu strony, jeśli nie ma pytań egzaminacyjnych
    return page.quiz || [];
  }
  
  const matchedQuestions = questionMatcher.findQuestionsForPage(page, examQuestions);
  
  // Zwróć maksymalnie 3 najlepsze pytania
  return matchedQuestions.slice(0, 3).map(match => match.question);
}

function save(){ localStorage.setItem("istqb_results", JSON.stringify(state.results)); renderProgress(); }

function shuffle(arr){ return arr.map(v=>[Math.random(),v]).sort((a,b)=>a[0]-b[0]).map(x=>x[1]); }

// Format flashcard answers as dash-prefixed lines instead of a single sentence.
// Splits on semicolons, newlines or bullet characters and joins with <br> and leading '- '.
function formatFlashAnswer(answer){
  if(answer===undefined || answer===null) return "—";
  const raw = String(answer);
  // If already contains list/line HTML, return as-is
  if(/<\s*(ul|ol|br|div|p)/i.test(raw)) return raw;
  const parts = raw.split(/\n|[;•]/).map(s=>s.trim()).filter(Boolean);
  if(parts.length<=1) return raw;
  return parts.map(p=>`- ${p.replace(/^[-•]\s*/, '')}`).join('<br>');
}

function renderTOC(){
  const toc = syllabus.map((ch, idx)=>`<h3>${idx<6?"Rozdział":""}</h3>
    <button data-idx="${idx}" class="${state.current===idx?"active":""}">${ch.title}</button>`).join("");
  $$("#toc").innerHTML = toc + `<h3>Egzamin</h3><button data-exam="1">Egzamin</button>`;
  $all("#toc button").forEach(b=>{
    if(b.dataset.idx!==undefined){ b.onclick=()=>{state.current=+b.dataset.idx; state.page=0; renderChapter();}; }
    if(b.dataset.exam){ b.onclick=()=>renderFinalExam(); }
  });
}

function renderChapter(){
  const ch = syllabus[state.current];
  if(ch.pages && ch.pages.length){
    renderPagedChapter(ch);
  } else {
    $$("#reading").innerHTML = `<div class="tag">${ch.title}</div>${ch.read||""}`;
  }
  $$("#after").innerHTML = ``;
  renderTOC();
}

function renderPagedChapter(ch){
  const total = ch.pages.length;
  const idx = Math.max(0, Math.min(state.page, total-1));
  const page = ch.pages[idx];
  const host = $$("#reading");
  const isLast = idx===total-1;
  const parts = String(page.id||"").split(".");
  const isSub = parts.length>=3; // 1.1.2 → podrozdział; 1.1 → rozdział
  const parentId = isSub ? `${parts[0]}.${parts[1]}` : null;
  const parent = isSub ? (ch.pages||[]).find(p=>p.id===parentId) : null;
  const parentTitle = parent ? parent.title : null;

  const contentHtml = isSub ? `<h2>${page.title}</h2>${page.html}` : `${page.html}`;
  host.innerHTML = `
    <div class="chapterHeader is-chapter">
      <div class="row1">
        <div class="crumb">${ch.title}</div>
        <div class="spacer"></div>
        <div class="hint">Strona ${idx+1}/${total}</div>
      </div>
      <div class="row2">
        <span class="badge">Rozdział</span>
        <h3 class="chapterTitle">${isSub ? (parentTitle||parentId) : page.title}</h3>
      </div>
    </div>
    <div>${contentHtml}</div>
    ${renderInlineStudy(ch)}
    ${isLast? renderInlineFooterEnd() : renderInlinePager()}
  `;

  const nextBtn = $$("#nextPage"); if(nextBtn){ nextBtn.onclick = ()=>{ state.page = Math.min(state.page+1, total-1); state.currentQuestionIndex = 0; renderPagedChapter(ch); }; }
  const prevBtn = $$("#prevPage"); if(prevBtn){ prevBtn.onclick = ()=>{ state.page = Math.max(state.page-1, 0); state.currentQuestionIndex = 0; renderPagedChapter(ch); }; if(idx===0) { prevBtn.disabled=true; prevBtn.style.visibility='hidden'; } }
  const nextChapBtn = $$("#endNextChapter"); if(nextChapBtn){ nextChapBtn.onclick = ()=>{ state.current = Math.min(state.current+1, syllabus.length-1); state.page=0; renderChapter(); }; }

  // Wire inline flash
  const flip = $$("#inlineFlip");
  if(flip){
    let flipped=false; 
    // Użyj fiszek z poziomu strony, jeśli istnieją
    const pageFlashcards = page.flashcards || [];
    const chapterFlashcards = ch.flashcards || [];
    const flashcards = pageFlashcards.length > 0 ? pageFlashcards : chapterFlashcards;
    const fc = flashcards[0];
    flip.innerHTML = fc? fc.q : "Brak fiszek";
    flip.onclick = ()=>{
      flipped=!flipped;
      flip.classList.toggle("flipped", flipped);
      flip.innerHTML = flipped? formatFlashAnswer(fc?.a||"—") : (fc?.q||"—");
    };
  }

  // Wire inline quiz (single question)
  const check = $$("#inlineCheck");
  if(check){
    check.onclick = ()=>{
      const questions = getQuestionsForPage(page);
      const q = questions[0];
      if(!q) return;
      const labels = $all(".inline-quiz .opt", host);
      const inputs = $all(".inline-quiz input");
      const checked = inputs.filter(n=>n.checked).map(n=>+n.value);
      const correctSet = new Set(Array.isArray(q.a)? q.a : [q.a]);
      labels.forEach((lb,oi)=>{
        lb.classList.remove("correct","wrong");
        if(correctSet.has(oi)) lb.classList.add("correct");
        if(checked.includes(oi) && !correctSet.has(oi)) lb.classList.add("wrong");
      });
    };
  }
  
  // Wire next question button
  const nextQuestionBtn = $$("#nextQuestion");
  if(nextQuestionBtn){
    nextQuestionBtn.onclick = ()=>{
      const questions = getQuestionsForPage(page);
      if(questions.length <= 1) return;
      
      state.currentQuestionIndex = (state.currentQuestionIndex + 1) % questions.length;
      const q = questions[state.currentQuestionIndex];
      const multi = q && Array.isArray(q.a);
      
      // Zaktualizuj treść pytania
      const quizDiv = $$(".inline-quiz");
      if(quizDiv){
        quizDiv.innerHTML = `
          <div class="tag">Pytanie ${state.currentQuestionIndex + 1} z ${questions.length}</div>
          <div style="font-weight:700;margin-bottom:6px">${q.q}</div>
          ${q.opt.map((o,oi)=>{
            const input = multi? `<input type=\"checkbox\" name=\"iq\" value=\"${oi}\">` : `<input type=\"radio\" name=\"iq\" value=\"${oi}\">`;
            return `<label class=\"opt\">${input} ${o}</label>`;
          }).join("")}
          <div class="controls">
            <button class="btn" id="inlineCheck">Sprawdź</button>
            ${questions.length > 1 ? `<button class="btn flat" id="nextQuestion">Następne pytanie</button>` : ''}
          </div>
        `;
        
        // Ponownie podłącz obsługę przycisków
        const newCheck = $$("#inlineCheck");
        if(newCheck){
          newCheck.onclick = ()=>{
            const labels = $all(".inline-quiz .opt", host);
            const inputs = $all(".inline-quiz input");
            const checked = inputs.filter(n=>n.checked).map(n=>+n.value);
            const correctSet = new Set(Array.isArray(q.a)? q.a : [q.a]);
            labels.forEach((lb,oi)=>{
              lb.classList.remove("correct","wrong");
              if(correctSet.has(oi)) lb.classList.add("correct");
              if(checked.includes(oi) && !correctSet.has(oi)) lb.classList.add("wrong");
            });
          };
        }
        
        // Ponownie podłącz przycisk następnego pytania
        const newNextBtn = $$("#nextQuestion");
        if(newNextBtn){
          newNextBtn.onclick = nextQuestionBtn.onclick;
        }
      }
    };
  }
}

function renderInlinePager(){
  return `<div class="pageFooter">
    <button class="btn flat" id="prevPage">← Poprzednia strona</button>
    <button class="btn" id="nextPage">Następna strona →</button>
  </div>`;
}

function renderInlineStudy(ch){
  const total = ch.pages.length;
  const idx = Math.max(0, Math.min(state.page, total-1));
  const page = ch.pages[idx];
  
  // Użyj fiszek z poziomu strony, jeśli istnieją
  const pageFlashcards = page.flashcards || [];
  const chapterFlashcards = ch.flashcards || [];
  const flashcards = pageFlashcards.length > 0 ? pageFlashcards : chapterFlashcards;
  
  // Pobierz pytania używając nowego systemu linkowania
  const questions = getQuestionsForPage(page);
  
  // Resetuj indeks pytania przy zmianie strony
  if (state.currentQuestionIndex >= questions.length) {
    state.currentQuestionIndex = 0;
  }
  
  // Wybierz pytanie do wyświetlenia
  const q = questions[state.currentQuestionIndex];
  const multi = q && Array.isArray(q.a);
  
  return `
    <div class="inline">
      <div class="tag">Fiszka</div>
      <div class="flip" id="inlineFlip"></div>
    </div>
    ${q? `<div class="inline inline-quiz">
      <div class="tag">Pytanie ${questions.length > 1 ? `(${state.currentQuestionIndex + 1} z ${questions.length})` : ''}</div>
      <div style="font-weight:700;margin-bottom:6px">${q.q}</div>
      ${q.opt.map((o,oi)=>{
        const input = multi? `<input type=\"checkbox\" name=\"iq\" value=\"${oi}\">` : `<input type=\"radio\" name=\"iq\" value=\"${oi}\">`;
        return `<label class=\"opt\">${input} ${o}</label>`;
      }).join("")}
      <div class="controls">
        <button class="btn" id="inlineCheck">Sprawdź</button>
        ${questions.length > 1 ? `<button class="btn flat" id="nextQuestion">Następne pytanie</button>` : ''}
      </div>
    </div>` : ``}
  `;
}

function renderInlineFooterEnd(){
  return `<div class="pageFooter">
    <button class="btn flat" id="prevPage">← Poprzednia strona</button>
    <button class="btn" id="endNextChapter">Następny rozdział →</button>
  </div>`;
}

function renderProgress(){
  const res = state.results; let passed = 0, total = 0;
  syllabus.forEach(ch=>{ if(!ch.quiz) return; const key = ch.id+":quiz"; if(res[key]) passed += res[key].score; if(res[key]) total += res[key].total; });
  const hint = `Zebrane punkty: <b>${passed}</b> / ${total||"—"}`;
  $$("#progressHint").innerHTML = hint;
}

function startFlashcards(){
  const ch = syllabus[state.current];
  const list = shuffle(ch.flashcards || []);
  state.flash = {side:"q", i:0, list};
  const host = $$("#after");
  host.innerHTML = `
    <div class="flash">
      <div class="tag">Fiszka ${state.flash.i+1}/${list.length}</div>
      <div class="flip" id="flip">${list[0]?.q||"Brak fiszek"}</div>
      <div class="row">
        <button class="btn" id="know">Znam</button>
        <button class="btn secondary" id="dont">Nie wiem</button>
        <button class="btn flat" id="nextF">Następna</button>
      </div>
      <div class="hint">Kliknij kartę, aby obrócić.</div>
    </div>`;
  const flip = $$("#flip");
  flip.onclick = ()=>{
    state.flash.side = state.flash.side==="q"?"a":"q";
    flip.classList.toggle("flipped");
    flip.innerHTML = state.flash.side==="q"?list[state.flash.i].q:formatFlashAnswer(list[state.flash.i].a);
  };
  $$("#nextF").onclick = ()=>{ state.flash.i = (state.flash.i+1)%list.length; state.flash.side="q"; flip.classList.remove("flipped"); flip.innerHTML=list[state.flash.i].q; $$(".tag").innerHTML=`Fiszka ${state.flash.i+1}/${list.length}`; };
  $$("#know").onclick = ()=>alert("Super! Przejdź do mini‑testu gdy będziesz gotowy.");
  $$("#dont").onclick = ()=>alert("Zapisz trudne fiszki – możesz je dodać/rozszerzyć w danych.");
}

function startQuiz(mode="chapter"){
  const ch = syllabus[state.current];
  const questions = shuffle([...(questionsForChapter(ch.id))]);
  renderQuiz(questions, ch.id+":quiz", ch.title, mode);
}

function flattenAllQuestions(){
  // Wszystkie dostępne pytania (40 + A1–A26 = 76) w losowej kolejności,
  // z losową kolejnością opcji dla każdego pytania.
  const questions = examA.map(x=>({
    q:x.q,
    opt:[...x.opt],
    a:Array.isArray(x.a)? [...x.a] : x.a,
    exp:x.exp,
    why:x.why,
    chapter:x.chapter
  }));

  // Potasuj kolejność pytań
  const shuffledQuestions = shuffle(questions);

  // Dla każdego pytania potasuj opcje i zaktualizuj indeks(y) poprawnej odpowiedzi
  return shuffledQuestions.map(q=>{
    const original = q.opt.map((o,idx)=>({o, idx}));
    const shuffledOpts = shuffle(original);
    const indexMap = new Map(shuffledOpts.map((it,newIdx)=>[it.idx,newIdx]));
    let newAnswer;
    if(Array.isArray(q.a)){
      newAnswer = q.a.map(oldIdx=>indexMap.get(oldIdx)).sort((a,b)=>a-b);
    } else {
      newAnswer = indexMap.get(q.a);
    }
    return {
      q: q.q,
      opt: shuffledOpts.map(x=>x.o),
      a: newAnswer,
      exp: q.exp,
      why: q.why,
      chapter: q.chapter
    };
  });
}

function renderQuiz(questions, key, label, mode){
  const host = $$("#after");
  host.innerHTML = `<div class="quiz">
    <div class="tag">${mode==="exam"?"Egzamin":`Mini‑test: ${label}`}</div>
    ${questions.map((q,i)=>`
      <div class="q">
        <div><b>${i+1}. ${q.q}</b></div>
        ${q.html||""}
        ${q.opt.map((o,oi)=>{
          const multi = Array.isArray(q.a);
          const input = multi? `<input type="checkbox" name="q${i}" value="${oi}">` : `<input type="radio" name="q${i}" value="${oi}">`;
          return `<label class="opt">${input} ${o}</label>`;
        }).join("")}
        <div class="explain" data-exp style="display:none">${formatWhy(q)}</div>
      </div>`).join("")}
    <div class="controls">
      <button class="btn" id="check">Sprawdź</button>
      <button class="btn flat" id="resetQuiz">Wyczyść odpowiedzi</button>
    </div>
    <div id="quizResult"></div>
  </div>`;

  $$("#check").onclick = ()=>{
    let score=0; questions.forEach((q,i)=>{
      const inputs = $all(`input[name=q${i}]`);
      const checked = inputs.filter(n=>n.checked).map(n=>+n.value);
      const labels = $all(`.q:nth-child(${i+2}) .opt`, host); // +1 for tag div
      labels.forEach((lb,oi)=>{
        lb.classList.remove("correct","wrong");
        const correctSet = new Set(Array.isArray(q.a)? q.a : [q.a]);
        if(correctSet.has(oi)) lb.classList.add("correct");
        if(checked.includes(oi) && !correctSet.has(oi)) lb.classList.add("wrong");
      });
      const correctSet = new Set(Array.isArray(q.a)? q.a : [q.a]);
      const chosenSet = new Set(checked);
      let ok = chosenSet.size===correctSet.size;
      if(ok){ for(const c of chosenSet){ if(!correctSet.has(c)){ ok=false; break; } } }
      if(ok) score++;
      const exp = $all(`.q:nth-child(${i+2}) [data-exp]`, host)[0]; if(exp) exp.style.display="block";
    });
    const percent = Math.round(100*score/questions.length);
    $$("#quizResult").innerHTML = `<div class="result"><b>Wynik:</b> ${score}/${questions.length} (${percent}%). ${mode==="exam"?`Próg zdania: 65%. ${percent>=65?"✅ ZALICZONO":"❌ Nie zaliczono"}`:""}</div>`;
    state.results[key] = {score, total:questions.length, ts:Date.now()}; save();
  };

  $$("#resetQuiz").onclick = ()=>{ $all("input[type=radio]", host).forEach(i=>i.checked=false); $$("#quizResult").innerHTML=""; $all(".opt", host).forEach(o=>o.classList.remove("correct","wrong")); };
}

// Zwróć pytania dla danego rozdziału na podstawie przypisania z examA
function questionsForChapter(chId){
  return examA.filter(x=>x.chapter===chId).map(x=>({q:x.q, opt:x.opt, a:x.a, exp:x.exp, why:x.why}));
}

function renderFinalExam(){
  // Załaduj pełny zestaw 76 pytań, pytania i opcje w losowej kolejności za każdym razem
  state.current = 0; renderTOC();
  const all = flattenAllQuestions();
  $$("#reading").innerHTML = `<div class=\"tag\">Egzamin</div>
    <h2>Egzamin</h2>
    <p>Losowy zestaw wszystkich pytań (40 + A1–A26 = 76). Próg zaliczenia: <b>65%</b>.</p>
    <div class=\"controls\"><button class=\"btn flat\" id=\"backToSyllabus\">← Wróć do Sylabusa</button></div>`;
  const back = $$("#backToSyllabus");
  if(back){ back.onclick = ()=>{ state.current = 0; state.page = 0; $$("#after").innerHTML = ""; renderChapter(); }; }
  renderQuiz(all, "final:exam", "Egzamin", "exam");
}

// Wire UI (usunięto dolne przyciski nauki)
// usunięto przycisk egzaminu końcowego
$$("#resetBtn").onclick = ()=>{ if(confirm("Wyczyścić zapisane wyniki?")){ localStorage.removeItem("istqb_results"); state.results={}; renderProgress(); }}

// Init
loadExamQuestions(); // Załaduj pytania egzaminacyjne
renderTOC();
renderChapter();
renderProgress();
</script>
<!-- pdf.js (CDN) do renderowania pełnego sylabusa w rozdziałach -->
<!-- Usunięty pdf.js, nie wykorzystujemy podglądu PDF -->
</body>
</html>
